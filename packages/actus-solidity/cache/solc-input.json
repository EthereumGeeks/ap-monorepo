{
  "language": "Solidity",
  "sources": {
    "contracts/Core/ACTUSTypes.sol": {
      "content": "pragma solidity ^0.6.4;\r\n\r\n\r\n/**\r\n * @title ACTUSTypes\r\n * @notice Contains all type definitions for ACTUS. See ACTUS-Dictionary for definitions\r\n */\r\ncontract ACTUSTypes {\r\n\r\n    // constants used throughout\r\n    uint256 constant public PRECISION = 18;\r\n    int256 constant public ONE_POINT_ZERO = 1 * 10 ** 18;\r\n    uint256 constant MAX_CYCLE_SIZE = 120;\r\n    uint256 constant MAX_EVENT_SCHEDULE_SIZE = 120;\r\n\r\n    // IPS\r\n    enum P {D, W, M, Q, H, Y} // P=[D=Days, W=Weeks, M=Months, Q=Quarters, H=Halfyear, Y=Year]\r\n    enum S {LONG, SHORT} // S=[+=long stub,- short stub, {} if S empty then - for short stub]\r\n    struct IPS {\r\n        uint256 i; // I=Integer\r\n        P p;\r\n        S s;\r\n        bool isSet;\r\n    }\r\n\r\n    struct IP {\r\n        uint256 i;\r\n        P p;\r\n        bool isSet;\r\n    }\r\n\r\n    //               0    1   2   3   4    5   6   7   8     9  10   11  12  13   14  15  16  17    18  19  20   21  22\r\n    enum EventType {NE, IED, FP, PR, PD, PRF, PY, PP, IP, IPCI, CE, RRF, RR, DV, PRD, MR, TD, SC, IPCB, MD, XD, STD, AD}\r\n    enum Calendar {NC, MF}\r\n    enum BusinessDayConvention {NOS, SCF, SCMF, CSF, CSMF, SCP, SCMP, CSP, CSMP}\r\n    enum ClearingHouse {Y, N}\r\n    enum ContractRole {RPA, RPL, RFL, PFL, RF, PF, BUY, SEL, COL, CNO, UDL, UDLP, UDLM}\r\n    enum ContractPerformance {PF, DL, DQ, DF, MD, TD}\r\n    enum ContractType {PAM, ANN, NAM, LAM, LAX, CLM, UMP, CSH, STK, COM, SWAPS, SWPPV, FXOUT, CAPFL, FUTUR, OPTNS, CEG, CEC} // required ?\r\n    enum CyclePointOfInterestPayment {B, E} // or E, B?\r\n    enum CyclePointOfRateReset {B, E}\r\n    enum DayCountConvention {AA, A360, A365, _30E360ISDA, _30E360, _28E336}\r\n    enum EndOfMonthConvention {SD, EOM}\r\n    enum FeeBasis {A, N}\r\n    enum InterestCalculationBase {NT, NTIED, NTL}\r\n    enum OptionExerciseType {E, B, A}\r\n    enum OptionType {C, P, CP}\r\n    enum PenaltyType {O, A, N, I}\r\n    enum PrepaymentEffect {N, A, M}\r\n    enum ScalingEffect {_000, I00, _0N0, IN0}\r\n    enum Seniority {S, J}\r\n    enum Unit {BRL, BSH, GLN, CUU, MWH, PND, STN, TON, TRO}\r\n    enum ContractReferenceType {CNT, CID, MOC, EID, CST}\r\n    enum ContractReferenceRole {UDL, FIL, SEL, COVE, COVI}\r\n\r\n    struct ContractReference {\r\n        bytes32 object;\r\n        ContractReferenceType _type;\r\n        ContractReferenceRole role;\r\n    }\r\n\r\n    struct State {\r\n        ContractPerformance contractPerformance;\r\n\r\n        uint256 statusDate;\r\n        uint256 nonPerformingDate;\r\n        uint256 maturityDate;\r\n        uint256 exerciseDate;\r\n        uint256 terminationDate;\r\n\r\n        int256 notionalPrincipal;\r\n        // int256 notionalPrincipal2;\r\n        int256 accruedInterest;\r\n        // int256 accruedInterest2;\r\n        int256 feeAccrued;\r\n        int256 nominalInterestRate;\r\n        // int256 nominalInterestRate2;\r\n        // int256 interestCalculationBaseAmount;\r\n        int256 interestScalingMultiplier;\r\n        int256 notionalScalingMultiplier;\r\n        int256 nextPrincipalRedemptionPayment;\r\n        int256 exerciseAmount;\r\n    }\r\n\r\n    // subset of the ACTUS terms object\r\n    // contains only attributes which are used in POFs and STFs\r\n    struct LifecycleTerms {\r\n        Calendar calendar;\r\n        ContractRole contractRole;\r\n        DayCountConvention dayCountConvention;\r\n        BusinessDayConvention businessDayConvention;\r\n        EndOfMonthConvention endOfMonthConvention;\r\n        ScalingEffect scalingEffect;\r\n        PenaltyType penaltyType;\r\n        FeeBasis feeBasis;\r\n        ContractPerformance creditEventTypeCovered;\r\n\r\n        address currency;\r\n        address settlementCurrency;\r\n\r\n        bytes32 marketObjectCodeRateReset;\r\n\r\n        uint256 statusDate;\r\n        uint256 maturityDate;\r\n\r\n        int256 notionalPrincipal;\r\n        int256 nominalInterestRate;\r\n        int256 feeAccrued;\r\n        int256 accruedInterest;\r\n        int256 rateMultiplier;\r\n        int256 rateSpread;\r\n        int256 feeRate;\r\n        int256 nextResetRate;\r\n        int256 penaltyRate;\r\n        int256 premiumDiscountAtIED;\r\n        int256 priceAtPurchaseDate;\r\n        int256 nextPrincipalRedemptionPayment;\r\n        int256 coverageOfCreditEnhancement;\r\n        int256 lifeCap;\r\n        int256 lifeFloor;\r\n        int256 periodCap;\r\n        int256 periodFloor;\r\n\r\n        IP gracePeriod;\r\n        IP delinquencyPeriod;\r\n\r\n        // for simplification since terms are limited only two contract references\r\n        // - make ContractReference top level and skip ContractStructure\r\n        ContractReference contractReference_1;\r\n        ContractReference contractReference_2;\r\n    }\r\n\r\n    // subset of the ACTUS terms object\r\n    // contains only attributes which are used in the schedule generation\r\n    struct GeneratingTerms {\r\n        ScalingEffect scalingEffect;\r\n\r\n        uint256 contractDealDate;\r\n        uint256 statusDate;\r\n        uint256 initialExchangeDate;\r\n        uint256 maturityDate;\r\n        uint256 purchaseDate;\r\n        uint256 capitalizationEndDate;\r\n        uint256 cycleAnchorDateOfInterestPayment;\r\n        uint256 cycleAnchorDateOfRateReset;\r\n        uint256 cycleAnchorDateOfScalingIndex;\r\n        uint256 cycleAnchorDateOfFee;\r\n        uint256 cycleAnchorDateOfPrincipalRedemption;\r\n\r\n        IPS cycleOfInterestPayment;\r\n        IPS cycleOfRateReset;\r\n        IPS cycleOfScalingIndex;\r\n        IPS cycleOfFee;\r\n        IPS cycleOfPrincipalRedemption;\r\n\r\n        IP gracePeriod;\r\n        IP delinquencyPeriod;\r\n    }\r\n\r\n    // ACTUS terms object\r\n    struct Terms {\r\n        ContractType contractType;\r\n        Calendar calendar;\r\n        ContractRole contractRole;\r\n        DayCountConvention dayCountConvention;\r\n        BusinessDayConvention businessDayConvention;\r\n        EndOfMonthConvention endOfMonthConvention;\r\n        ScalingEffect scalingEffect;\r\n        PenaltyType penaltyType;\r\n        FeeBasis feeBasis;\r\n        ContractPerformance creditEventTypeCovered;\r\n\r\n        address currency;\r\n        address settlementCurrency;\r\n\r\n        bytes32 marketObjectCodeRateReset;\r\n\r\n        uint256 contractDealDate;\r\n        uint256 statusDate;\r\n        uint256 initialExchangeDate;\r\n        uint256 maturityDate;\r\n        uint256 purchaseDate;\r\n        uint256 capitalizationEndDate;\r\n        uint256 cycleAnchorDateOfInterestPayment;\r\n        uint256 cycleAnchorDateOfRateReset;\r\n        uint256 cycleAnchorDateOfScalingIndex;\r\n        uint256 cycleAnchorDateOfFee;\r\n        uint256 cycleAnchorDateOfPrincipalRedemption;\r\n\r\n        int256 notionalPrincipal;\r\n        int256 nominalInterestRate;\r\n        int256 feeAccrued;\r\n        int256 accruedInterest;\r\n        int256 rateMultiplier;\r\n        int256 rateSpread;\r\n        int256 feeRate;\r\n        int256 nextResetRate;\r\n        int256 penaltyRate;\r\n        int256 premiumDiscountAtIED;\r\n        int256 priceAtPurchaseDate;\r\n        int256 nextPrincipalRedemptionPayment;\r\n        int256 coverageOfCreditEnhancement;\r\n        int256 lifeCap;\r\n        int256 lifeFloor;\r\n        int256 periodCap;\r\n        int256 periodFloor;\r\n\r\n        IPS cycleOfInterestPayment;\r\n        IPS cycleOfRateReset;\r\n        IPS cycleOfScalingIndex;\r\n        IPS cycleOfFee;\r\n        IPS cycleOfPrincipalRedemption;\r\n\r\n        IP gracePeriod;\r\n        IP delinquencyPeriod;\r\n\r\n        // for simplification since terms are limited only two contract references\r\n        // - make ContractReference top level and skip ContractStructure\r\n        ContractReference contractReference_1;\r\n        ContractReference contractReference_2;\r\n    }\r\n}\r\n"
    },
    "contracts/Core/Conventions/BusinessDayConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title BusinessDayConvention\n * @notice Contains conventions of how to handle non-business days when generating schedules of events.\n * The events schedule time can be shifted or not, if shifted it is possible that it is shifted to the next\n * or previous valid business days, etc.\n */\ncontract BusinessDayConvention is ACTUSTypes {\n\n    /**\n     * @notice Used in POFs and STFs for DCFs.\n     * No shifting is applied if a Calc/Shift instead of Shift/Calc BDC is provided.\n     */\n    function shiftCalcTime(\n        uint256 timestamp,\n        BusinessDayConvention convention,\n        Calendar calendar\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (\n            convention == BusinessDayConvention.CSF ||\n            convention == BusinessDayConvention.CSMF ||\n            convention == BusinessDayConvention.CSP ||\n            convention == BusinessDayConvention.CSMP\n        ) {\n            return timestamp;\n        }\n\n        return shiftEventTime(timestamp, convention, calendar);\n    }\n\n    /*\n     * @notice Used for generating event schedules (for single events and event cycles schedules).\n     * This convention assumes that when shifting the events schedule time according\n     * to a BDC, the time is shifted first and calculations are performed thereafter.\n     * (Calculations in POFs and STFs are based on the shifted time as well)\n     */\n    function shiftEventTime(\n        uint256 timestamp,\n        BusinessDayConvention convention,\n        Calendar calendar\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // Shift/Calc Following, Calc/Shift following\n        if (convention == BusinessDayConvention.SCF || convention == BusinessDayConvention.CSF) {\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n        // Shift/Calc Modified Following, Calc/Shift Modified following\n        // Same as unmodified if shifted date is in the same month, if not it returns the previous buiness-day\n        } else if (convention == BusinessDayConvention.SCMF || convention == BusinessDayConvention.CSMF) {\n            uint256 followingOrSameBusinessDay = getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n            if (BokkyPooBahsDateTimeLibrary.getMonth(followingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\n                return followingOrSameBusinessDay;\n            }\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n        // Shift/Calc Preceeding, Calc/Shift Preceeding\n        } else if (convention == BusinessDayConvention.SCP || convention == BusinessDayConvention.CSP) {\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n        // Shift/Calc Modified Preceeding, Calc/Shift Modified Preceeding\n        // Same as unmodified if shifted date is in the same month, if not it returns the following buiness-day\n        } else if (convention == BusinessDayConvention.SCMP || convention == BusinessDayConvention.CSMP) {\n            uint256 preceedingOrSameBusinessDay = getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n            if (BokkyPooBahsDateTimeLibrary.getMonth(preceedingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\n                return preceedingOrSameBusinessDay;\n            }\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n        }\n\n        return timestamp;\n    }\n\n    /**\n     * @notice Returns the following business day if a non-business day is provided.\n     * (Returns the same day if calendar != MondayToFriday)\n     */\n    function getClosestBusinessDaySameDayOrFollowing(uint256 timestamp, Calendar calendar)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (calendar == Calendar.MF) {\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 2);\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 1);\n            }\n        }\n        return timestamp;\n    }\n\n    /**\n     * @notice Returns the previous buiness day if a non-businessday is provided.\n     * (Returns the same day if calendar != MondayToFriday)\n     */\n    function getClosestBusinessDaySameDayOrPreceeding(uint256 timestamp, Calendar calendar)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (calendar == Calendar.MF) {\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 1);\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 2);\n            }\n        }\n        return timestamp;\n    }\n}\n"
    },
    "contracts/external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "pragma solidity ^0.6.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}"
    },
    "contracts/Core/Conventions/ContractDefaultConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title ContractDefaultConvention\n */\ncontract ContractDefaultConvention is ACTUSTypes {\n\n    /**\n     * @notice Returns the performance indicator for a given performance\n     * (used a mutliplier in POFs)\n     */\n    function performanceIndicator(ContractPerformance contractPerformance)\n        internal\n        pure\n        returns (int8)\n    {\n        if (contractPerformance == ContractPerformance.DF) return 0;\n        return 1;\n    }\n}"
    },
    "contracts/Core/Conventions/ContractRoleConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title ContractRoleConvention\n */\ncontract ContractRoleConvention is ACTUSTypes {\n\n    /**\n     * Returns the role sign for a given Contract Role.\n     */\n    function roleSign(ContractRole contractRole)\n        internal\n        pure\n        returns (int8)\n    {\n        if (contractRole == ContractRole.RPA) return 1;\n        if (contractRole == ContractRole.RPL) return -1;\n\n        if (contractRole == ContractRole.BUY) return 1;\n        if (contractRole == ContractRole.SEL) return -1;\n\n        if (contractRole == ContractRole.RFL) return 1;\n        if (contractRole == ContractRole.PFL) return -1;\n\n        revert(\"ContractRoleConvention.roleSign: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/Core/Conventions/DayCountConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/drafts/SignedSafeMath.sol\";\nimport \"../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\nimport \"../SignedMath.sol\";\n\n\n/**\n * @title DayCountConvention\n * @notice Implements various ISDA day count conventions as specified by ACTUS\n */\ncontract DayCountConvention is ACTUSTypes {\n\n    using SafeMath for uint;\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n    /**\n     * Returns the fraction of the year between two timestamps.\n     */\n    function yearFraction(\n        uint256 startTimestamp,\n        uint256 endTimestamp,\n        DayCountConvention ipdc,\n        uint256 maturityDate\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        require(endTimestamp >= startTimestamp, \"Core.yearFraction: START_NOT_BEFORE_END\");\n        if (ipdc == DayCountConvention.AA) {\n            return actualActual(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention.A360) {\n            return actualThreeSixty(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention.A365) {\n            return actualThreeSixtyFive(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention._30E360) {\n            return thirtyEThreeSixty(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention._30E360ISDA) {\n            return thirtyEThreeSixtyISDA(startTimestamp, endTimestamp, maturityDate);\n        } else if (ipdc == DayCountConvention._28E336) {\n            // not implemented yet\n            revert(\"DayCountConvention.yearFraction: ATTRIBUTE_NOT_SUPPORTED.\");\n        } else {\n            revert(\"DayCountConvention.yearFraction: ATTRIBUTE_NOT_FOUND.\");\n        }\n    }\n\n    /**\n     * ISDA A/A day count convention\n     */\n    function actualActual(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Year = BokkyPooBahsDateTimeLibrary.getYear(startTime);\n        uint256 d2Year = BokkyPooBahsDateTimeLibrary.getYear(endTime);\n\n        int256 firstBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(startTime)) ? 366 : 365;\n\n        if (d1Year == d2Year) {\n            return int256(BokkyPooBahsDateTimeLibrary.diffDays(startTime, endTime)).floatDiv(firstBasis);\n        }\n\n        int256 secondBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(endTime)) ? 366 : 365;\n\n        int256 firstFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\n            startTime,\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d1Year.add(1), 1, 1)\n        )).floatDiv(firstBasis);\n        int256 secondFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d2Year, 1, 1),\n            endTime\n        )).floatDiv(secondBasis);\n\n        return firstFraction.add(secondFraction).add(int256(d2Year.sub(d1Year).sub(1)));\n    }\n\n    /**\n     * ISDA A/360 day count convention\n     */\n    function actualThreeSixty(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(360));\n    }\n\n    /**\n     * ISDA A/365-Fixed day count convention\n     */\n    function actualThreeSixtyFive(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(365));\n    }\n\n    /**\n     * ISDA 30E/360 day count convention\n     */\n    function thirtyEThreeSixty(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Day;\n        uint256 d1Month;\n        uint256 d1Year;\n\n        uint256 d2Day;\n        uint256 d2Month;\n        uint256 d2Year;\n\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\n\n        if (d1Day == 31) {\n            d1Day = 30;\n        }\n\n        if (d2Day == 31) {\n            d2Day = 30;\n        }\n\n        int256 delD = int256(d2Day).sub(int256(d1Day));\n        int256 delM = int256(d2Month).sub(int256(d1Month));\n        int256 delY = int256(d2Year).sub(int256(d1Year));\n\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\n    }\n\n    /**\n     * ISDA 30E/360-ISDA day count convention\n     */\n    function thirtyEThreeSixtyISDA(uint256 startTime, uint256 endTime, uint256 maturityDate)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Day;\n        uint256 d1Month;\n        uint256 d1Year;\n\n        uint256 d2Day;\n        uint256 d2Month;\n        uint256 d2Year;\n\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\n\n        if (d1Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime)) {\n            d1Day = 30;\n        }\n\n        if (!(endTime == maturityDate && d2Month == 2) && d2Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(endTime)) {\n            d2Day = 30;\n        }\n\n        int256 delD = int256(d2Day).sub(int256(d1Day));\n        int256 delM = int256(d2Month).sub(int256(d1Month));\n        int256 delY = int256(d2Year).sub(int256(d1Year));\n\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\n    }\n}"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/drafts/SignedSafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/Core/SignedMath.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\n/**\n * Advanced math library for signed integers\n * (including floats which are represented as multiples of 10 ** 18)\n */\nlibrary SignedMath {\n\n    int256 constant private INT256_MIN = -2 ** 255;\n\n    uint256 constant public PRECISION = 18;\n    uint256 constant public MULTIPLICATOR = 10 ** PRECISION;\n\n\n    /**\n     * @dev The product of a and b has to be less than INT256_MAX (~10 ** 76),\n     * as devision (normalization) is performed after multiplication\n     * Upper boundary would be (10 ** 58) * (MULTIPLICATOR) == ~10 ** 76\n     */\n    function floatMult(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        if (a == 0 || b == 0) return 0;\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedMath.floatMult: OVERFLOW_DETECTED\");\n        int256 c = a * b;\n        require(c / a == b, \"SignedMath.floatMult: OVERFLOW_DETECTED\");\n\n        // normalize (divide by MULTIPLICATOR)\n        int256 d = c / int256(MULTIPLICATOR);\n        require(d != 0, \"SignedMath.floatMult: CANNOT_REPRESENT_GRANULARITY\");\n\n        return d;\n    }\n\n    function floatDiv(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        require(b != 0, \"SignedMath.floatDiv: DIVIDED_BY_ZERO\");\n\n        // normalize (multiply by MULTIPLICATOR)\n        if (a == 0) return 0;\n        int256 c = a * int256(MULTIPLICATOR);\n        require(c / a == int256(MULTIPLICATOR), \"SignedMath.floatDiv: OVERFLOW_DETECTED\");\n\n        require(!(b == -1 && a == INT256_MIN), \"SignedMath.floatDiv: OVERFLOW_DETECTED\");\n        int256 d = c / b;\n        require(d != 0, \"SignedMath.floatDiv: CANNOT_REPRESENT_GRANULARITY\");\n\n        return d;\n    }\n\n    /**\n        * @dev Returns the smallest of two signed numbers.\n        */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n            return a <= b ? a : b;\n    }\n\n    /**\n        * @dev Returns the largest of two signed numbers.\n        */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n            return a >= b ? a : b;\n    }\n}\n"
    },
    "contracts/Core/Conventions/EndOfMonthConvention.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title EndOfMonthConvention\n * @notice Implements the ACTUS end of month convention.\n */\ncontract EndOfMonthConvention is ACTUSTypes {\n\n    /**\n     * This function makes an adjustment on the end of month convention.\n     * @dev The following is considered to dertermine if schedule dates are shifted to the end of month:\n     * - The convention SD (same day) means not adjusting, EM (end of month) means adjusting\n     * - Dates are only shifted if the schedule start date is an end-of-month date\n     * - Dates are only shifted if the schedule cycle is based on an \"M\" period unit or multiple thereof\n     * @param eomc the end of month convention to adjust\n     * @param startTime timestamp of the cycle start\n     * @param cycle the cycle struct\n     * @return the adjusted end of month convention\n     */\n    function adjustEndOfMonthConvention(\n        EndOfMonthConvention eomc,\n        uint256 startTime,\n        IPS memory cycle\n    )\n        public\n        pure\n        returns (EndOfMonthConvention)\n    {\n        if (eomc == EndOfMonthConvention.EOM) {\n            // check if startTime is last day in month and schedule has month based period\n            // otherwise switch to SD convention\n            if (\n                BokkyPooBahsDateTimeLibrary.getDay(startTime) == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime) &&\n                (cycle.p == P.M || cycle.p == P.Q || cycle.p == P.H)\n            ) {\n                return EndOfMonthConvention.EOM;\n            }\n            return EndOfMonthConvention.SD;\n        } else if (eomc == EndOfMonthConvention.SD) {\n            return EndOfMonthConvention.SD;\n        }\n        revert(\"EndOfMonthConvention.adjustEndOfMonthConvention: ATTRIBUTE_NOT_FOUND.\");\n    }\n}\n"
    },
    "contracts/Core/Core.sol": {
      "content": "pragma solidity ^0.6.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./ACTUSTypes.sol\";\r\nimport \"./Utils.sol\";\r\nimport \"./Schedule.sol\";\r\n\r\nimport \"./Conventions/BusinessDayConvention.sol\";\r\nimport \"./Conventions/ContractDefaultConvention.sol\";\r\nimport \"./Conventions/ContractRoleConvention.sol\";\r\nimport \"./Conventions/DayCountConvention.sol\";\r\nimport \"./Conventions/EndOfMonthConvention.sol\";\r\n\r\n\r\n/**\r\n * @title Core\r\n * @notice Contains all type definitions, conventions as specified by the ACTUS Standard\r\n * and utility methods for generating event schedules\r\n */\r\ncontract Core is\r\n    ACTUSTypes,\r\n    BusinessDayConvention,\r\n    ContractDefaultConvention,\r\n    ContractRoleConvention,\r\n    DayCountConvention,\r\n    EndOfMonthConvention,\r\n    Utils,\r\n    Schedule\r\n{}\r\n"
    },
    "contracts/Core/Utils.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"./ACTUSTypes.sol\";\nimport \"./Conventions/BusinessDayConvention.sol\";\n\n\n/**\n * @title Utils\n * @notice Utility methods used throughout Core and all Engines\n */\ncontract Utils is ACTUSTypes, BusinessDayConvention {\n\n    function encodeEvent(EventType eventType, uint256 scheduleTime)\n        public\n        pure\n        returns (bytes32)\n    {\n        return (\n            bytes32(uint256(uint8(eventType))) << 248 |\n            bytes32(scheduleTime)\n        );\n    }\n\n    function decodeEvent(bytes32 _event)\n        public\n        pure\n        returns (EventType, uint256)\n    {\n        EventType eventType = EventType(uint8(uint256(_event >> 248)));\n        uint256 scheduleTime = uint256(uint64(uint256(_event)));\n\n        return (eventType, scheduleTime);\n    }\n\n    /**\n     * @notice Returns the event time for a given schedule time\n     * by applying the BDC specified in the terms\n     */\n    function computeEventTimeForEvent(bytes32 _event, LifecycleTerms memory terms)\n        public\n        pure\n        returns (uint256)\n    {\n        (, uint256 scheduleTime) = decodeEvent(_event);\n        return shiftEventTime(scheduleTime, terms.businessDayConvention, terms.calendar);\n    }\n\n    /**\n     * @notice Returns the epoch offset for a given event type to determine the\n     * correct order of events if multiple events have the same timestamp\n     */\n    function getEpochOffset(EventType eventType)\n        public\n        pure\n        returns (uint256)\n    {\n        if (eventType == EventType.IED) return 20;\n        if (eventType == EventType.PR) return 25;\n        if (eventType == EventType.IP) return 30;\n        if (eventType == EventType.IPCI) return 40;\n        if (eventType == EventType.FP) return 50;\n        if (eventType == EventType.DV) return 60;\n        if (eventType == EventType.MR) return 80;\n        if (eventType == EventType.RRF) return 90;\n        if (eventType == EventType.RR) return 100;\n        if (eventType == EventType.SC) return 110;\n        if (eventType == EventType.IPCB) return 120;\n        if (eventType == EventType.PRD) return 130;\n        if (eventType == EventType.TD) return 140;\n        if (eventType == EventType.STD) return 150;\n        if (eventType == EventType.MD) return 160;\n        if (eventType == EventType.AD) return 950;\n        return 0;\n    }\n\n    /**\n     * @notice Applies a period in IP notation to a given timestamp\n     */\n    function getTimestampPlusPeriod(IP memory period, uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 newTimestamp;\n\n        if (period.p == P.D) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, period.i);\n        } else if (period.p == P.W) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, period.i * 7);\n        } else if (period.p == P.M) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, period.i);\n        } else if (period.p == P.Q) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, period.i * 3);\n        } else if (period.p == P.H) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, period.i * 6);\n        } else if (period.p == P.Y) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, period.i);\n        } else {\n            revert(\"Core.getTimestampPlusPeriod: ATTRIBUTE_NOT_FOUND\");\n        }\n\n        return newTimestamp;\n    }\n\n    /**\n     * @notice Checks if a timestamp is in a given range.\n     */\n    function isInSegment(\n        uint256 timestamp,\n        uint256 startTimestamp,\n        uint256 endTimestamp\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (startTimestamp > endTimestamp) return false;\n        if (startTimestamp <= timestamp && timestamp <= endTimestamp) return true;\n        return false;\n    }\n}\n"
    },
    "contracts/Core/Schedule.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"./ACTUSTypes.sol\";\nimport \"./Utils.sol\";\n\n\n/**\n * @title Schedule\n * @notice Methods related to generating event schedules.\n */\ncontract Schedule is ACTUSTypes, Utils {\n\n    /**\n     * @notice Applies the cycle n - times (n := cycleIndex) to a given date\n     */\n    function getNextCycleDate(IPS memory cycle, uint256 cycleStart, uint256 cycleIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 newTimestamp;\n\n        if (cycle.p == P.D) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(cycleStart, cycle.i * cycleIndex);\n        } else if (cycle.p == P.W) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(cycleStart, cycle.i * 7 * cycleIndex);\n        } else if (cycle.p == P.M) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(cycleStart, cycle.i * cycleIndex);\n        } else if (cycle.p == P.Q) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(cycleStart, cycle.i * 3 * cycleIndex);\n        } else if (cycle.p == P.H) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(cycleStart, cycle.i * 6 * cycleIndex);\n        } else if (cycle.p == P.Y) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(cycleStart, cycle.i * cycleIndex);\n        } else {\n            revert(\"Schedule.getNextCycleDate: ATTRIBUTE_NOT_FOUND\");\n        }\n\n        return newTimestamp;\n    }\n\n    /**\n     * This function computes an array of UNIX timestamps that\n     * represent dates in a cycle falling within a given segment.\n     * @dev There are some notable edge cases: If the cycle is \"not set\" we return the start end end dates\n     * of the cycle if they lie within the segment. Otherwise and empty array is returned.\n     * @param cycleStart the start time of the cycle\n     * @param cycleEnd the end time of the cycle\n     * @param cycle struct that describe sthe cycle\n     * @param addEndTime specifies if the timestamp of the end of the cycle should be added to the result if it falls in the segment\n     * @param segmentStart start time of the segment\n     * @param segmentEnd end time of the segment\n     * @return an array of timestamps from the given cycle that fall within the specified segement\n     */\n    function computeDatesFromCycleSegment(\n        uint256 cycleStart,\n        uint256 cycleEnd,\n        IPS memory cycle,\n        bool addEndTime,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        internal\n        pure\n        returns (uint256[MAX_CYCLE_SIZE] memory)\n    {\n        uint256[MAX_CYCLE_SIZE] memory dates;\n        uint256 index = 0;\n\n        // if the cycle is not set we return only the cycle start end end dates under these conditions:\n        // we return the cycle start, if it's in the segment\n        // in case of addEntTime = true, the cycle end is also returned if in the segment\n        if (cycle.isSet == false) {\n            if (isInSegment(cycleStart, segmentStart, segmentEnd)) {\n                dates[index] = cycleStart;\n                index++;\n            }\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\n                if (addEndTime == true) dates[index] = cycleEnd;\n            }\n            return dates;\n        }\n\n        uint256 date = cycleStart;\n        uint256 cycleIndex = 0;\n\n        // walk through the cycle and create the cycle dates to be returned\n        while (date < cycleEnd) {\n            // if date is in segment and MAX_CYCLE_SIZE is not reached add it to the output array\n            if (isInSegment(date, segmentStart, segmentEnd)) {\n                require(index < (MAX_CYCLE_SIZE - 2), \"Schedule.computeDatesFromCycle: MAX_CYCLE_SIZE\");\n                dates[index] = date;\n                index++;\n            }\n\n            cycleIndex++;\n\n\n            date = getNextCycleDate(cycle, cycleStart, cycleIndex);\n\n        }\n\n        // add additional time at the end if addEndTime\n        if (addEndTime == true) {\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\n                dates[index] = cycleEnd;\n            }\n        }\n\n        // handle a special case where S is set to LONG (e.g. for trimming a cycle to the maturity date)\n        if (index > 0 && isInSegment(dates[index - 1], segmentStart, segmentEnd)) {\n            if (cycle.s == S.LONG && index > 1 && cycleEnd != date) {\n                dates[index - 1] = dates[index];\n                delete dates[index];\n            }\n        }\n\n        return dates;\n    }\n}\n"
    },
    "contracts/Engines/ANNEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./IEngine.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title ANNEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a ANN contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract ANNEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * todo implement annuity calculator\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.notionalScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.interestScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.accruedInterest = roleSign(terms.contractRole) * terms.accruedInterest;\n        state.feeAccrued = terms.feeAccrued;\n        // annuity calculator to be implemented\n        state.nextPrincipalRedemptionPayment = roleSign(terms.contractRole) * terms.nextPrincipalRedemptionPayment;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * todo rate reset, scaling, interest calculation base\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // initial exchange\n        if (isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\n            _eventSchedule[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\n            index++;\n        }\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                _eventSchedule[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // principal redemption at maturity\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true)  {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        if (eventType == EventType.IP) {\n            uint256 index = 0;\n\n            // interest payment related (covers pre-repayment period only,\n            // starting with PRANX interest is paid following the PR schedule)\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n            ) {\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.maturityDate,\n                    terms.cycleOfInterestPayment,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (interestPaymentSchedule[i] <= terms.capitalizationEndDate) continue;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IP, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.IPCI) {\n            uint256 index = 0;\n\n            // IPCI\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n                && terms.capitalizationEndDate != 0\n                && terms.capitalizationEndDate < terms.cycleAnchorDateOfPrincipalRedemption\n            ) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.capitalizationEndDate,\n                    cycleOfInterestCapitalization,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IPCI, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.FP) {\n            uint256 index = 0;\n\n            // fees\n            if (terms.cycleOfFee.isSet == true && terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.PR) {\n            uint256 index = 0;\n\n            // principal redemption\n            uint256[MAX_CYCLE_SIZE] memory principalRedemptionSchedule = computeDatesFromCycleSegment(\n                terms.cycleAnchorDateOfPrincipalRedemption,\n                terms.maturityDate,\n                terms.cycleOfPrincipalRedemption,\n                false,\n                segmentStart,\n                segmentEnd\n            );\n            for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                if (principalRedemptionSchedule[i] == 0) break;\n                if (isInSegment(principalRedemptionSchedule[i], segmentStart, segmentEnd) == false) continue;\n                _eventSchedule[index] = encodeEvent(EventType.PR, principalRedemptionSchedule[i]);\n                index++;\n            }\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n        /*\n         * Note:\n         * not supported: IPCB events, PRD events\n         */\n        if (eventType == EventType.AD) return STF_PAM_AD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_PAM_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return STF_ANN_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IPCI) return STF_ANN_IPCI(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return STF_ANN_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return STF_PAM_PP(terms, state, scheduleTime, externalData);\n        //if (eventType == EventType.PRD) return STF_PAM_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PR) return STF_ANN_PR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_ANN_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PY) return STF_PAM_PY(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RRF) return STF_PAM_RRF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RR) return STF_ANN_RR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SC) return STF_ANN_SC(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_PAM_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"ANNEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * todo IPCB events and Icb state variable, Icb state variable updates in IP-paying events\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note: all ANN payoff functions that rely on NAM/LAM have been replaced by PAM\n         * actus-solidity currently doesn't support interestCalculationBase, thus we can use PAM\n         *\n         * There is a reference to a POF_ANN_PR function which was added because PAM doesn't have PR Events in ACTUS 1.0\n         * and NAM, which ANN refers to in the specification, is not yet supported\n         *\n         * not supported: IPCB events, PRD events\n         */\n        if (eventType == EventType.AD) return 0; // Analysis Event\n        if (eventType == EventType.IPCI) return 0; // Interest Capitalization Event\n        if (eventType == EventType.RRF) return 0; // Rate Reset Fixed\n        if (eventType == EventType.RR) return 0; // Rate Reset Variable\n        if (eventType == EventType.SC) return 0; // Scaling Index Revision\n        if (eventType == EventType.CE) return 0; // Credit Event\n        if (eventType == EventType.FP) return POF_PAM_FP(terms, state, scheduleTime, externalData); // Fee Payment\n        if (eventType == EventType.IED) return POF_PAM_IED(terms, state, scheduleTime, externalData); // Intital Exchange\n        if (eventType == EventType.IP) return POF_PAM_IP(terms, state, scheduleTime, externalData); // Interest Payment\n        if (eventType == EventType.PP) return POF_PAM_PP(terms, state, scheduleTime, externalData); // Principal Prepayment\n        //if (eventType == EventType.PRD) return POF_PAM_PRD(terms, state, scheduleTime, externalData); // Purchase\n        if (eventType == EventType.PR) return POF_ANN_PR(terms, state, scheduleTime, externalData); // Principal Redemption\n        if (eventType == EventType.MD) return POF_PAM_MD(terms, state, scheduleTime, externalData); // Maturity\n        if (eventType == EventType.PY) return POF_PAM_PY(terms, state, scheduleTime, externalData); // Penalty Payment\n        if (eventType == EventType.TD) return POF_PAM_TD(terms, state, scheduleTime, externalData); // Termination\n\n        revert(\"ANNEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}"
    },
    "contracts/Engines/IEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/ACTUSTypes.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\nabstract contract IEngine is ACTUSTypes {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        virtual\n        returns (State memory);\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        virtual\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        virtual\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        virtual\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        virtual\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        virtual\n        returns (bool);\n}\n"
    },
    "contracts/Engines/BaseEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./IEngine.sol\";\n\n\n/**\n * @title BaseEngine\n * @notice Implements computeStateForEvent and computePayoffForEvent for all Engines.\n * All Engine contracts have to inherit from BaseEngine and implement all abstract methods.\n */\nabstract contract BaseEngine is Core, IEngine {\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        override\n        returns (int256)\n    {\n        // if alternative settlementCurrency is set then apply fxRate to payoff\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n            return payoffFunction(\n                terms,\n                state,\n                _event,\n                externalData\n            ).floatMult(int256(externalData));\n        }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Abstract method which has to be implemented by the inheriting Engine contract.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        virtual\n        returns (State memory);\n\n    /**\n     * @notice Abstract method which has to be implemented by the inheriting Engine contract.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        virtual\n        returns (int256);\n}"
    },
    "contracts/Engines/STF.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) currently used by all Engines\n */\ncontract STF is Core {\n\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_NE (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        return state;\n    }\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_AD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM fee payment events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM initial exchange\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.statusDate = scheduleTime;\n\n        state.accruedInterest = terms.accruedInterest;\n\n        // if (terms.cycleAnchorDateOfInterestPayment != 0 &&\n        //   terms.cycleAnchorDateOfInterestPayment < terms.initialExchangeDate\n        // ) {\n        //   state.accruedInterest = state.nominalInterestRate\n        //   .floatMult(state.notionalPrincipal)\n        //   .floatMult(\n        //     yearFraction(\n        //       terms.cycleAnchorDateOfInterestPayment,\n        //       scheduleTime,\n        //       terms.dayCountConvention,\n        //       terms.maturityDate\n        //     )\n        //   );\n        // }\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM interest capitalization\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IPCI (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.notionalPrincipal = state.notionalPrincipal\n        .add(\n            state.accruedInterest\n            .add(\n                state.nominalInterestRate\n                .floatMult(state.notionalPrincipal)\n                .floatMult(timeFromLastEvent)\n            )\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM interest payment\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal prepayment\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal -= 0; // riskFactor(terms.objectCodeOfPrepaymentModel, scheduleTime, state, terms) * state.notionalPrincipal;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal redemption\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM penalty payments\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PY (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM fixed rate resets\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_RRF (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = terms.nextResetRate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM variable rate resets\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_RR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        // int256 rate = //riskFactor(terms.marketObjectCodeOfRateReset, scheduleTime, state, terms)\n        // \t* terms.rateMultiplier + terms.rateSpread;\n\n        // apply external rate, multiply with rateMultiplier and add the spread\n        int256 rate = int256(uint256(externalData)).floatMult(terms.rateMultiplier).add(terms.rateSpread);\n\n        // deltaRate is the difference between the rate that includes external data, spread and multiplier and the currently active rate from the state\n        int256 deltaRate = rate.sub(state.nominalInterestRate);\n\n        // apply period cap/floor\n        // the deltaRate (the interest rate change) cannot be bigger than the period cap\n        // and not smaller than the period floor\n        // math: deltaRate = min(max(deltaRate, periodFloor),lifeCap)\n        deltaRate = deltaRate.max(terms.periodFloor).min(terms.periodCap);\n        rate = state.nominalInterestRate.add(deltaRate);\n\n        // apply life cap/floor\n        // the rate cannot be higher than the lifeCap\n        // and not smaller than the lifeFloor\n        // math: rate = min(max(rate,lifeFloor),lifeCap)\n        rate = rate.max(terms.lifeFloor).min(terms.lifeCap);\n\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = rate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM scaling index revision events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_SC (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n\n        if ((terms.scalingEffect == ScalingEffect.I00) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.interestScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n        if ((terms.scalingEffect == ScalingEffect._0N0) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.notionalScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal redemption\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM termination events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_TD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.nominalInterestRate = 0;\n        state.accruedInterest = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.TD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM credit events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_CE (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(State memory)\n    {\n        uint256 nonPerformingDate = (state.nonPerformingDate == 0)\n            ? shiftEventTime(scheduleTime, terms.businessDayConvention, terms.calendar)\n            : state.nonPerformingDate;\n\n        uint256 currentTimestamp = uint256(externalData);\n\n        bool isInGracePeriod = false;\n        if (terms.gracePeriod.isSet) {\n            uint256 graceDate = getTimestampPlusPeriod(terms.gracePeriod, nonPerformingDate);\n            if (currentTimestamp <= graceDate) {\n                state.contractPerformance = ContractPerformance.DL;\n                isInGracePeriod = true;\n            }\n        }\n\n        if (terms.delinquencyPeriod.isSet && !isInGracePeriod) {\n            uint256 delinquencyDate = getTimestampPlusPeriod(terms.delinquencyPeriod, nonPerformingDate);\n            if (currentTimestamp <= delinquencyDate) {\n                state.contractPerformance = ContractPerformance.DQ;\n            } else {\n                state.contractPerformance = ContractPerformance.DF;\n            }\n        }\n\n        if (state.nonPerformingDate == 0) {\n            state.nonPerformingDate = shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar\n            );\n        }\n\n        return state;\n    }\n\n    // function STF_ANN_AD (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    // function STF_ANN_CD (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.ContractPerformance = ContractPerformance.DF;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    // function STF_ANN_FP (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = 0;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_ANN_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.statusDate = scheduleTime;\n\n        state.accruedInterest = terms.accruedInterest;\n\n        // if (terms.cycleAnchorDateOfInterestPayment != 0 &&\n        //   terms.cycleAnchorDateOfInterestPayment < terms.initialExchangeDate\n        // ) {\n        //   state.accruedInterest = state.nominalInterestRate\n        //   .floatMult(state.notionalPrincipal)\n        //   .floatMult(\n        //     yearFraction(\n        //       shiftCalcTime(terms.cycleAnchorDateOfInterestPayment, terms.businessDayConvention, terms.calendar),\n        //       shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n        //       terms.dayCountConvention,\n        //       terms.maturityDate\n        //     )\n        //   );\n        // }\n\n        return state;\n    }\n\n    function STF_ANN_IPCI (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.accruedInterest\n            .add(\n                state.nominalInterestRate\n                .floatMult(state.notionalPrincipal)\n                .floatMult(timeFromLastEvent)\n            )\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // function STF_ANN_PP (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.notionalPrincipal -= 0; // riskFactor(terms.objectCodeOfPrepaymentModel, scheduleTime, state, terms) * state.notionalPrincipal;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_ANN_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = state.notionalPrincipal\n        .sub(\n            roleSign(terms.contractRole)\n            * (\n                roleSign(terms.contractRole)\n                * state.notionalPrincipal\n            )\n            .min(\n                roleSign(terms.contractRole)\n                * (\n                    state.nextPrincipalRedemptionPayment\n                    .sub(state.accruedInterest)\n                )\n            )\n        );\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0.0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // STF_PAM_PY\n    // function STF_ANN_PY (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    // function STF_ANN_RRF (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.nominalInterestRate = terms.nextResetRate;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_ANN_RR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        // int256 rate = //riskFactor(terms.marketObjectCodeOfRateReset, scheduleTime, state, terms)\n        // \t* terms.rateMultiplier + terms.rateSpread;\n        int256 rate = int256(externalData) * terms.rateMultiplier + terms.rateSpread;\n        int256 deltaRate = rate.sub(state.nominalInterestRate);\n\n            // apply period cap/floor\n        if ((terms.lifeCap < deltaRate) && (terms.lifeCap < ((-1) * terms.periodFloor))) {\n            deltaRate = terms.lifeCap;\n        } else if (deltaRate < ((-1) * terms.periodFloor)) {\n            deltaRate = ((-1) * terms.periodFloor);\n        }\n        rate = state.nominalInterestRate.add(deltaRate);\n\n        // apply life cap/floor\n        if (terms.lifeCap < rate && terms.lifeCap < terms.lifeFloor) {\n            rate = terms.lifeCap;\n        } else if (rate < terms.lifeFloor) {\n            rate = terms.lifeFloor;\n        }\n\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = rate;\n        state.nextPrincipalRedemptionPayment = 0; // TODO: implement annuity calculator\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_SC (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n\n        if ((terms.scalingEffect == ScalingEffect.I00) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.interestScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n        if ((terms.scalingEffect == ScalingEffect._0N0) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.notionalScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // function STF_ANN_TD (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    // //   int256 timeFromLastEvent = yearFraction(\n    // //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    // //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    // //     terms.dayCountConvention,\n    // //     terms.maturityDate\n    // //   );\n    //   state.notionalPrincipal = 0;\n    //   state.nominalAccrued = 0;\n    //   state.feeAccrued = 0;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_CEG_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_XD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        // decode state.notionalPrincipal of underlying from externalData\n        state.exerciseAmount = terms.coverageOfCreditEnhancement.floatMult(int256(externalData));\n        state.exerciseDate = scheduleTime;\n\n        if (terms.feeBasis == FeeBasis.A) {\n            state.feeAccrued = roleSign(terms.contractRole) * terms.feeRate;\n        } else {\n            state.feeAccrued = state.feeAccrued\n                    .add(\n                        yearFraction(\n                            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                            terms.dayCountConvention,\n                            terms.maturityDate\n                        )\n                        .floatMult(terms.feeRate)\n                        .floatMult(state.notionalPrincipal)\n                    );\n        }\n\n        return state;\n    }\n\n    function STF_CEG_STD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_PRD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.feeRate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.feeAccrued = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // function STF_CEG_TD (\n    //     LifecycleTerms memory terms,\n    //     State memory state,\n    //     uint256 scheduleTime,\n    //     bytes32 externalData\n    // )\n    //     internal\n    //     pure\n    //     returns (State memory)\n    // {\n    //     // uint256 timeFromLastEvent = yearFraction(\n    //     //   shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     //   shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     //   terms.dayCountConvention,\n    //     //   terms.maturityDate\n    //     // );\n    //     state.notionalPrincipal = 0;\n    //     state.accruedInterest = 0;\n    //     state.feeAccrued = 0;\n    //     state.statusDate = scheduleTime;\n\n    //     return state;\n    // }\n}\n"
    },
    "contracts/Engines/POF.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all payoff functions (POFs) currently used by all Engines\n */\ncontract POF is Core {\n\n    /**\n     * Calculate the pay-off for PAM Fees. The method how to calculate the fee\n     * heavily depends on the selected Fee Basis.\n     * @return the fee amount for PAM contracts\n     */\n    function POF_PAM_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.feeBasis == FeeBasis.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.feeRate\n            );\n        }\n\n        return (\n            state.feeAccrued\n                .add(\n                    yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(terms.feeRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n        );\n    }\n\n    /**\n     * Calculate the payoff for the initial exchange\n     * @return the payoff at iniitial exchange for PAM contracts\n     */\n    function POF_PAM_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * (-1)\n            * terms.notionalPrincipal\n                .add(terms.premiumDiscountAtIED)\n        );\n    }\n\n    /**\n     * Calculate the interest payment payoff\n     * @return the interest amount to pay for PAM contracts\n     */\n    function POF_PAM_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            state.interestScalingMultiplier\n                .floatMult(\n                    state.accruedInterest\n                    .add(\n                        yearFraction(\n                            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                            terms.dayCountConvention,\n                            terms.maturityDate\n                        )\n                        .floatMult(state.nominalInterestRate)\n                        .floatMult(state.notionalPrincipal)\n                    )\n                )\n        );\n    }\n\n    /**\n     * Calculate the principal prepayment payoff\n     * @return the principal prepayment amount for PAM contracts\n     */\n    function POF_PAM_PP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * state.notionalPrincipal\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of maturity\n     * @return the maturity payoff for PAM contracts\n     */\n    function POF_PAM_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            state.notionalScalingMultiplier\n                .floatMult(state.notionalPrincipal)\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of a penalty event\n     * @return the penalty amount for PAM contracts\n     */\n    function POF_PAM_PY (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.penaltyType == PenaltyType.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.penaltyRate\n            );\n        } else if (terms.penaltyType == PenaltyType.N) {\n            return (\n                roleSign(terms.contractRole)\n                * yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(terms.penaltyRate)\n                    .floatMult(state.notionalPrincipal)\n            );\n        } else {\n            return (\n                roleSign(terms.contractRole)\n                * yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(state.notionalPrincipal)\n            );\n        }\n    }\n\n    /**\n     * Calculate the payoff in case of termination of a contract\n     * @return the termination payoff amount for PAM contracts\n     */\n    function POF_PAM_TD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * terms.priceAtPurchaseDate\n                .add(state.accruedInterest)\n                .add(\n                    yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(state.nominalInterestRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n        );\n    }\n\n    /**\n     * Calculate the payoff for principal redemption\n     * @dev This is a replacement of the POF_PR_NAM which we have not implemented, yet\n     * @return the principal redemption amount for ANN contracts\n     */\n    function POF_ANN_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            (state.notionalScalingMultiplier * roleSign(terms.contractRole))\n                .floatMult(\n                    (roleSign(terms.contractRole) * state.notionalPrincipal)\n                    .min(\n                            roleSign(terms.contractRole)\n                            * (\n                                state.nextPrincipalRedemptionPayment\n                                - state.accruedInterest\n                                - yearFraction(\n                                    shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                                    shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                                    terms.dayCountConvention,\n                                    terms.maturityDate\n                                )\n                                .floatMult(state.nominalInterestRate)\n                                .floatMult(state.notionalPrincipal)\n                            )\n                        )\n                )\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of settlement\n     * @return the settlement payoff amount for CEG contracts\n     */\n    function POF_CEG_STD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return state.exerciseAmount + state.feeAccrued;\n    }\n\n    /**\n     * Calculate the pay-off for CEG Fees.\n     * @return the fee amount for CEG contracts\n     */\n    function POF_CEG_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.feeBasis == FeeBasis.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.feeRate\n            );\n        }\n\n        return (\n            state.feeAccrued\n                .add(\n                    yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(terms.feeRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n        );\n    }\n}"
    },
    "contracts/Engines/CECEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./IEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title CECEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a CEC contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n * inputs have to be multiplied by 10 ** 18, outputs have to multplied by 10 ** -18\n */\ncontract CECEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // maturity event\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true) {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.XD) return STF_CEG_XD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_CEG_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.STD) return STF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"CECEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.XD) return 0;\n        if (eventType == EventType.STD) return POF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return 0;\n\n        revert(\"CECEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/Engines/CEGEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./IEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title CEGEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a CEC contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n * inputs have to be multiplied by 10 ** 18, outputs have to multplied by 10 ** -18\n */\ncontract CEGEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.feeAccrued = terms.feeAccrued;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                _eventSchedule[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // maturity event\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true) {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        if (eventType == EventType.FP) {\n            uint256 index = 0;\n\n            // fees\n            if (terms.cycleOfFee.isSet == true && terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (hasUnderlying) {\n            // FP, MD events only scheduled up to execution of the Guarantee\n            if (\n                (eventType == EventType.FP || eventType == EventType.MD)\n                && underlyingState.exerciseAmount > int256(0)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n        // PRD events not supported\n        //if (eventType == EventType.PRD) return STF_CEG_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_CEG_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.XD) return STF_CEG_XD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.STD) return STF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_CEG_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"CEGEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        // PRD events not supported\n        if (eventType == EventType.CE) return 0;\n        // if (eventType == EventType.PRD) return POF_CEG_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return POF_CEG_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.XD) return 0;\n        if (eventType == EventType.STD) return POF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return 0;\n        \n        revert(\"CEGEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}"
    },
    "contracts/Engines/PAMEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./IEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title PAMEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a PAM contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract PAMEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return the initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.notionalScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.interestScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.accruedInterest = terms.accruedInterest;\n        state.feeAccrued = terms.feeAccrued;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // initial exchange\n        if (terms.purchaseDate == 0 && isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\n            _eventSchedule[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\n            index++;\n        }\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                _eventSchedule[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // principal redemption\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd)) {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns(bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        if (eventType == EventType.IP) {\n            uint256 index = 0;\n\n            // interest payment related (covers pre-repayment period only,\n            // starting with PRANX interest is paid following the PR schedule)\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n            ) {\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.maturityDate,\n                    terms.cycleOfInterestPayment,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (interestPaymentSchedule[i] <= terms.capitalizationEndDate) continue;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IP, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.IPCI) {\n            uint256 index = 0;\n\n            // IPCI\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n                && terms.capitalizationEndDate != 0\n            ) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.capitalizationEndDate,\n                    cycleOfInterestCapitalization,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IPCI, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.RR) {\n            uint256 index = 0;\n\n            // rate reset\n            if (terms.cycleOfRateReset.isSet == true && terms.cycleAnchorDateOfRateReset != 0) {\n                uint256[MAX_CYCLE_SIZE] memory rateResetSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfRateReset,\n                    terms.maturityDate,\n                    terms.cycleOfRateReset,\n                    false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (rateResetSchedule[i] == 0) break;\n                    if (isInSegment(rateResetSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.RR, rateResetSchedule[i]);\n                    index++;\n                }\n            }\n            // ... nextRateReset\n        }\n\n        if (eventType == EventType.FP) {\n            uint256 index = 0;\n\n            // fees\n            if (terms.cycleOfFee.isSet == true && terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.SC) {\n            uint256 index;\n\n            // scaling\n            if ((terms.scalingEffect != ScalingEffect._000)\n                && terms.cycleAnchorDateOfScalingIndex != 0\n            ) {\n                uint256[MAX_CYCLE_SIZE] memory scalingSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfScalingIndex,\n                    terms.maturityDate,\n                    terms.cycleOfScalingIndex,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (scalingSchedule[i] == 0) break;\n                    if (isInSegment(scalingSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.SC, scalingSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n        /*\n         * Note:\n         * Not supported: PRD events\n         */\n        if (eventType == EventType.AD) return STF_PAM_AD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_PAM_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return STF_PAM_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IPCI) return STF_PAM_IPCI(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return STF_PAM_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return STF_PAM_PP(terms, state, scheduleTime, externalData);\n        //if (eventType == EventType.PRD) return STF_PAM_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_PAM_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PY) return STF_PAM_PY(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RRF) return STF_PAM_RRF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RR) return STF_PAM_RR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SC) return STF_PAM_SC(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_PAM_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE)  return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"PAMEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * todo IPCB events and Icb state variable, Icb state variable updates in IP-paying events\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note: PAM contracts don't have IPCB and PR events.\n         * Not supported: PRD events\n         */\n\n        if (eventType == EventType.AD) return 0; // Analysis Event\n        if (eventType == EventType.IPCI) return 0; // Interest Capitalization Event\n        if (eventType == EventType.RRF) return 0; // Rate Reset Fixed\n        if (eventType == EventType.RR) return 0; // Rate Reset Variable\n        if (eventType == EventType.SC) return 0; // Scaling Index Revision\n        if (eventType == EventType.CE) return 0; // Credit Event\n        if (eventType == EventType.FP) return POF_PAM_FP(terms, state, scheduleTime, externalData); // Fee Payment\n        if (eventType == EventType.IED) return POF_PAM_IED(terms, state, scheduleTime, externalData); // Intital Exchange\n        if (eventType == EventType.IP) return POF_PAM_IP(terms, state, scheduleTime, externalData); // Interest Payment\n        if (eventType == EventType.PP) return POF_PAM_PP(terms, state, scheduleTime, externalData); // Principal Prepayment\n        //if (eventType == EventType.PRD) return POF_PAM_PRD(terms, state, scheduleTime, externalData); // Purchase\n        if (eventType == EventType.MD) return POF_PAM_MD(terms, state, scheduleTime, externalData); // Maturity\n        if (eventType == EventType.PY) return POF_PAM_PY(terms, state, scheduleTime, externalData); // Penalty Payment\n        if (eventType == EventType.TD) return POF_PAM_TD(terms, state, scheduleTime, externalData); // Termination\n\n        revert(\"PAMEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"
    },
    "contracts/test/TestCore.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestCore is Core {\n\n    function _performanceIndicator(ContractPerformance contractPerformance)\n        public\n        pure\n        returns (int8)\n    {\n        return performanceIndicator(contractPerformance);\n    }\n\n    function _roleSign(ContractRole contractRole)\n        public\n        pure\n        returns (int8)\n    {\n        return roleSign(contractRole);\n    }\n\n    function _yearFraction(\n        uint256 startTimestamp,\n        uint256 endTimestamp,\n        DayCountConvention ipdc,\n        uint256 maturityDate\n    )\n        public\n        pure\n        returns (int256)\n    {\n        return yearFraction(startTimestamp, endTimestamp, ipdc, maturityDate);\n    }\n\n    function _isInSegment(\n        uint256 timestamp,\n        uint256 startTimestamp,\n        uint256 endTimestamp\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return isInSegment(timestamp, startTimestamp, endTimestamp);\n    }\n\n    function _getTimestampPlusPeriod(IP memory period, uint256 timestamp)\n        public\n        pure\n        returns (uint256)\n    {\n        return getTimestampPlusPeriod(period, timestamp);\n    }\n\n    function _getNextCycleDate(IPS memory cycle, uint256 cycleStart, uint256 cycleIndex)\n        public\n        pure\n        returns (uint256)\n    {\n        return getNextCycleDate(cycle, cycleStart, cycleIndex);\n    }\n\n    function _computeDatesFromCycleSegment(\n        uint256 cycleStart,\n        uint256 cycleEnd,\n        IPS memory cycle,\n        bool addEndTime,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        returns (uint256[MAX_CYCLE_SIZE] memory)\n    {\n        return computeDatesFromCycleSegment(cycleStart, cycleEnd, cycle, addEndTime, segmentStart, segmentEnd);\n    }\n}\n"
    },
    "contracts/test/TestPOF.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Engines/POF.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestPOF is POF {\n    function _POF_PAM_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256) {\n        return POF_PAM_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_PAM_IED(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_PAM_IP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_PP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_PAM_PP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_PAM_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_PY (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_PAM_PY(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_PAM_TD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_PAM_TD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_ANN_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_ANN_PR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_CEG_STD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_CEG_STD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _POF_CEG_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(int256)\n    {\n        return POF_CEG_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n}"
    },
    "contracts/test/TestSignedMath.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/SignedMath.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestSignedMath {\n\n    using SignedMath for int;\n\n    function _floatMult(int256 a, int256 b)\n        public\n        pure\n        returns (int256)\n    {\n        return int(a).floatMult(b);\n    }\n\n    function _floatDiv(int256 a, int256 b)\n        public\n        pure\n        returns (int256)\n    {\n        return int(a).floatDiv(b);\n    }\n\n    function _min(int256 a, int256 b) public pure returns (int256) {\n        return int(a).min(b);\n    }\n\n    function _max(int256 a, int256 b) public pure returns (int256) {\n        return int(a).max(b);\n    }\n}\n"
    },
    "contracts/test/TestSTF.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Engines/STF.sol\";\n\n\n/**\n* These helper contracts expose internal functions for unit testing.\n*/\ncontract TestSTF is STF {\n    function _STF_PAM_AD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_AD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_FP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_IED(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_IPCI (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_IPCI(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_IP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_PP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_PP(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_PR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_PY (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_PY(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_RRF (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_RRF(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_RR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_RR(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_SC (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_SC(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_MD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_TD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_TD(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n\n    function _STF_PAM_CE (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n    public\n    pure\n    returns(State memory) {\n        return STF_PAM_CE(\n            terms,\n            state,\n            scheduleTime,\n            externalData\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}