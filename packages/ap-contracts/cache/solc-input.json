{
  "language": "Solidity",
  "sources": {
    "contracts/Core/AssetActor/AssetActor.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@atpar/actus-solidity/contracts/Core/Utils.sol\";\nimport \"@atpar/actus-solidity/contracts/Engines/IEngine.sol\";\n\nimport \"../SharedTypes.sol\";\nimport \"../ScheduleUtils.sol\";\nimport \"../Conversions.sol\";\nimport \"../AssetRegistry/IAssetRegistry.sol\";\nimport \"../TemplateRegistry/ITemplateRegistry.sol\";\nimport \"../MarketObjectRegistry/IMarketObjectRegistry.sol\";\nimport \"./IAssetActor.sol\";\n\n\n/**\n * @title AssetActor\n * @notice As the centerpiece of the ACTUS Protocol it is responsible for managing the\n * lifecycle of assets registered through the AssetRegistry. It acts as the executive of AP\n * by initializing the state of the asset and by processing the assets schedule as specified\n * in the TemplateRegistry. It derives the next state and the current outstanding payoff of\n * the asset by submitting the last finalized state to the corresponding ACTUS Engine.\n * The AssetActor stores the next state in the AssetRegistry, depending on if it is able\n * to settle the current outstanding payoff on behalf of the obligor.\n */\ncontract AssetActor is\n    SharedTypes,\n    Utils,\n    ScheduleUtils,\n    Conversions,\n    IAssetActor,\n    Ownable\n{\n\n    event ProgressedAsset(bytes32 indexed assetId, EventType eventType, uint256 scheduleTime, int256 payoff);\n    event Status(bytes32 indexed assetId, bytes32 statusMessage);\n\n\n    IAssetRegistry public assetRegistry;\n    ITemplateRegistry public templateRegistry;\n    IMarketObjectRegistry public marketObjectRegistry;\n\n    mapping(address => bool) public issuers;\n\n\n    modifier onlyRegisteredIssuer {\n        require(\n            issuers[msg.sender],\n            \"AssetActor.onlyRegisteredIssuer: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    constructor (\n        IAssetRegistry _assetRegistry,\n        ITemplateRegistry _templateRegistry,\n        IMarketObjectRegistry _marketObjectRegistry\n    )\n        public\n    {\n        assetRegistry = _assetRegistry;\n        templateRegistry = _templateRegistry;\n        marketObjectRegistry = _marketObjectRegistry;\n    }\n\n    /**\n     * @notice Whitelists the address of an issuer contract for initializing an asset.\n     * @dev Can only be called by the owner of the contract.\n     * @param issuer address of the issuer\n     */\n    function registerIssuer(address issuer) external onlyOwner {\n        issuers[issuer] = true;\n    }\n\n    /**\n     * @notice Proceeds with the next state of the asset based on the terms, the last state,\n     * market object data and the settlement status of current obligation (payoff).\n     * @dev Emits ProgressedAsset if the state of the asset was updated.\n     * @param assetId id of the asset\n     */\n    function progress(bytes32 assetId) public override {\n        // revert if the asset is not registered in the AssetRegistry\n        require(\n            assetRegistry.isRegistered(assetId),\n            \"AssetActor.progress: ASSET_DOES_NOT_EXIST\"\n        );\n\n        bytes32 _event = assetRegistry.getPendingEvent(assetId);\n        if (_event == bytes32(0)) _event = assetRegistry.getNextUnderlyingEvent(assetId);\n        if (_event == bytes32(0)) _event = assetRegistry.popNextScheduledEvent(assetId);\n\n        require(\n            _event != bytes32(0),\n            \"AssetActor.progress: NO_NEXT_EVENT\"\n        );\n\n        processEvent(assetId, _event);\n    }\n\n    /**\n     * @dev Emits ProgressedAsset if the state of the asset was updated.\n     * @param assetId id of the asset\n     */\n    function progressWith(bytes32 assetId, bytes32 _event) public override {\n        // revert if msg.sender is not authorized to update the asset\n        require(\n            assetRegistry.hasRootAccess(assetId, msg.sender),\n            \"AssetActor.progressWith: UNAUTHORIZED_SENDER\"\n        );\n\n        require(\n            assetRegistry.getPendingEvent(assetId) == bytes32(0),\n            \"AssetActor.progressWith: FOUND_PENDING_EVENT\"\n        );\n        require(\n            assetRegistry.getNextUnderlyingEvent(assetId) == bytes32(0),\n            \"AssetActor.progressWith: FOUND_UNDERLYING_EVENT\"\n        );\n\n        (, uint256 scheduledEventScheduleTime) = decodeEvent(assetRegistry.getNextScheduledEvent(assetId));\n        (, uint256 providedEventScheduleTime) = decodeEvent(_event);\n        require(\n            scheduledEventScheduleTime == 0 || (providedEventScheduleTime < scheduledEventScheduleTime),\n            \"AssetActor.progressWith: FOUND_EARLIER_EVENT\"\n        );\n\n        processEvent(assetId, _event);\n    }\n\n    /**\n     * @notice Derives the initial state of the asset from the provided custom terms and\n     * stores the initial state, the custom terms together with the ownership of the asset\n     * in the AssetRegistry.\n     * @dev Can only be called by a whitelisted issuer.\n     * @param assetId id of the asset\n     * @param ownership ownership of the asset\n     * @param templateId id of the financial template to use\n     * @param customTerms asset specific terms\n     * @param engine address of the ACTUS engine used for the spec. ContractType\n     * @param admin address of the admin of the asset (optional)\n     * @return true on success\n     */\n    function initialize(\n        bytes32 assetId,\n        AssetOwnership memory ownership,\n        bytes32 templateId,\n        CustomTerms memory customTerms,\n        address engine,\n        address admin\n    )\n        public\n        onlyRegisteredIssuer\n        override\n        returns (bool)\n    {\n        require(\n            assetId != bytes32(0) && engine != address(0),\n            \"AssetActor.initialize: INVALID_FUNCTION_PARAMETERS\"\n        );\n\n        // if anchorDate is not set, use block.timestamp\n        if (customTerms.anchorDate == uint256(0)) {\n            // solium-disable-next-line\n            customTerms.anchorDate = block.timestamp;\n        }\n\n        // compute the initial state of the asset using the LifecycleTerms\n        State memory initialState = IEngine(engine).computeInitialState(\n            deriveLifecycleTermsFromCustomTermsAndTemplateTerms(\n                templateRegistry.getTemplateTerms(templateId),\n                customTerms\n            )\n        );\n\n        // register the asset in the AssetRegistry\n        assetRegistry.registerAsset(\n            assetId,\n            ownership,\n            templateId,\n            customTerms,\n            initialState,\n            engine,\n            address(this),\n            admin\n        );\n\n        return true;\n    }\n\n    /**\n     * @notice Return true if event was settled\n     */\n    function processEvent(bytes32 assetId, bytes32 _event) internal {\n        LifecycleTerms memory terms = assetRegistry.getTerms(assetId);\n        State memory state = assetRegistry.getState(assetId);\n        address engineAddress = assetRegistry.getEngine(assetId);\n\n        // block progression if asset is has defaulted, terminated or reached maturity\n        require(\n            state.contractPerformance == ContractPerformance.PF\n            || state.contractPerformance == ContractPerformance.DL\n            || state.contractPerformance == ContractPerformance.DQ,\n            \"AssetActor.processEvent: ASSET_REACHED_FINAL_STATE\"\n        );\n\n        // get finalized state if asset is not performant\n        if (state.contractPerformance != ContractPerformance.PF) {\n            state = assetRegistry.getFinalizedState(assetId);\n        }\n\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        // revert if the scheduleTime of the next event is in the future\n        require(\n            // solium-disable-next-line\n            scheduleTime <= block.timestamp,\n            \"AssetActor.processEvent: NEXT_EVENT_NOT_YET_SCHEDULED\"\n        );\n\n        // get external data for the next event\n        // compute payoff and the next state by applying the event to the current state\n        int256 payoff = IEngine(engineAddress).computePayoffForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForPOF(_event, terms)\n        );\n        state = IEngine(engineAddress).computeStateForEvent(\n            terms,\n            state,\n            _event,\n            getExternalDataForSTF(_event, terms)\n        );\n\n        // try to settle payoff of event\n        // solium-disable-next-line\n        bool settledPayoff = settlePayoffForEvent(assetId, _event, payoff, terms);\n\n        if (settledPayoff == false) {\n            // if the obligation can't be fulfilled and the performance changed from performant to DL, DQ or DF,\n            // store the interim state of the asset (state if the current obligation was successfully settled)\n            // (if the obligation is later fulfilled before the asset reaches default,\n            // the interim state is used to derive subsequent states of the asset)\n            if (state.contractPerformance == ContractPerformance.PF) {\n                assetRegistry.setFinalizedState(assetId, state);\n            }\n\n            // store event as pending event for future settlement\n            assetRegistry.pushPendingEvent(assetId, _event);\n\n            // create CreditEvent\n            bytes32 ceEvent = encodeEvent(EventType.CE, scheduleTime);\n\n            // derive the actual state of the asset by applying the CreditEvent (updates performance of asset)\n            state = IEngine(engineAddress).computeStateForEvent(\n                terms,\n                state,\n                ceEvent,\n                getExternalDataForSTF(ceEvent, terms)\n            );\n        }\n\n        // store the resulting state\n        assetRegistry.setState(assetId, state);\n\n        emit ProgressedAsset(\n            assetId,\n            // if settlement failed a CreditEvent got processed instead\n            (settledPayoff == true) ? eventType : EventType.CE,\n            scheduleTime,\n            payoff\n        );\n    }\n\n    /**\n     * @notice Routes a payment to the designated beneficiary of the event obligation.\n     * @dev Checks if an owner of the specified cashflowId is set, if not it sends\n     * funds to the default beneficiary.\n     * @param assetId id of the asset which the payment relates to\n     * @param _event _event to settle the payoff for\n     * @param payoff payoff of the event\n     * @param terms terms of the asset\n     */\n    function settlePayoffForEvent(\n        bytes32 assetId,\n        bytes32 _event,\n        int256 payoff,\n        LifecycleTerms memory terms\n    )\n        internal\n        returns (bool)\n    {\n        require(\n            assetId != bytes32(0) && _event != bytes32(0),\n            \"AssetActor.settlePayoffForEvent: INVALID_FUNCTION_PARAMETERS\"\n        );\n\n        // return if there is no amount due\n        if (payoff == 0) return true;\n\n        // get the token address either from currency attribute or from the second contract reference\n        address token = terms.currency;\n        if (terms.contractReference_2.role == ContractReferenceRole.COVI) {\n            (token, ) = decodeCollateralObject(terms.contractReference_2.object);\n        }\n\n        AssetOwnership memory ownership = assetRegistry.getOwnership(assetId);\n\n        // derive cashflowId to determine ownership of the cashflow\n        (EventType eventType, ) = decodeEvent(_event);\n        int8 cashflowId = (payoff > 0) ? int8(uint8(eventType) + 1) : int8(uint8(eventType) + 1) * -1;\n        address payee = assetRegistry.getCashflowBeneficiary(assetId, cashflowId);\n        address payer;\n\n        // determine the payee and payer of the payment by checking the sign of the payoff\n        if (payoff > 0) {\n            // only allow for the obligor to settle the payment\n            payer = ownership.counterpartyObligor;\n            // use the default beneficiary if the there is no specific owner of the cashflow\n            if (payee == address(0)) {\n                payee = ownership.creatorBeneficiary;\n            }\n        } else {\n            // only allow for the obligor to settle the payment\n            payer = ownership.creatorObligor;\n            // use the default beneficiary if the there is no specific owner of the cashflow\n            if (payee == address(0)) {\n                payee = ownership.counterpartyBeneficiary;\n            }\n        }\n\n        // calculate the magnitude of the payoff\n        uint256 amount = (payoff > 0) ? uint256(payoff) : uint256(payoff * -1);\n\n        // check if allowance is set by the payer for the Asset Actor and that payer is able to cover payment\n        if (IERC20(token).allowance(payer, address(this)) < amount || IERC20(token).balanceOf(payer) < amount) {\n            emit Status(assetId, \"INSUFFICIENT_FUNDS\");\n            return false;\n        }\n\n        // try to transfer amount due from obligor to payee\n        return IERC20(token).transferFrom(payer, payee, amount);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data, block time, underlying asset state)\n     * used for evaluating the STF for a given event.\n     */\n    function getExternalDataForSTF(\n        bytes32 _event,\n        LifecycleTerms memory terms\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.RR) {\n            // get rate from MOR\n            (int256 resetRate, bool isSet) = marketObjectRegistry.getDataPointOfMarketObject(\n                terms.marketObjectCodeRateReset,\n                scheduleTime\n            );\n            if (isSet) return bytes32(resetRate);\n        } else if (eventType == EventType.CE) {\n            // get current timestamp\n            // solium-disable-next-line\n            return bytes32(block.timestamp);\n        } else if (eventType == EventType.XD) {\n            // get the remaining notionalPrincipal from the underlying\n            if (terms.contractReference_1.role == ContractReferenceRole.COVE) {\n                State memory underlyingState = assetRegistry.getState(terms.contractReference_1.object);\n                return bytes32(underlyingState.notionalPrincipal);\n            }\n        }\n\n        return bytes32(0);\n    }\n\n    /**\n     * @notice Retrieves external data (such as market object data)\n     * used for evaluating the POF for a given event.\n     */\n    function getExternalDataForPOF(\n        bytes32 _event,\n        LifecycleTerms memory terms\n    )\n        internal\n        view\n        returns (bytes32)\n    {\n        (, uint256  scheduleTime) = decodeEvent(_event);\n\n        if (terms.currency != terms.settlementCurrency) {\n            // get FX rate\n            (int256 fxRate, bool isSet) = marketObjectRegistry.getDataPointOfMarketObject(\n                keccak256(abi.encode(terms.currency, terms.settlementCurrency)),\n                scheduleTime\n            );\n            if (isSet) return bytes32(fxRate);\n        }\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/ownership/Ownable.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@atpar/actus-solidity/contracts/Core/Utils.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"./ACTUSTypes.sol\";\nimport \"./Conventions/BusinessDayConvention.sol\";\n\n\n/**\n * @title Utils\n * @notice Utility methods used throughout Core and all Engines\n */\ncontract Utils is ACTUSTypes, BusinessDayConvention {\n\n    function encodeEvent(EventType eventType, uint256 scheduleTime)\n        public\n        pure\n        returns (bytes32)\n    {\n        return (\n            bytes32(uint256(uint8(eventType))) << 248 |\n            bytes32(scheduleTime)\n        );\n    }\n\n    function decodeEvent(bytes32 _event)\n        public\n        pure\n        returns (EventType, uint256)\n    {\n        EventType eventType = EventType(uint8(uint256(_event >> 248)));\n        uint256 scheduleTime = uint256(uint64(uint256(_event)));\n\n        return (eventType, scheduleTime);\n    }\n\n    /**\n     * @notice Returns the event time for a given schedule time\n     * by applying the BDC specified in the terms\n     */\n    function computeEventTimeForEvent(bytes32 _event, LifecycleTerms memory terms)\n        public\n        pure\n        returns (uint256)\n    {\n        (, uint256 scheduleTime) = decodeEvent(_event);\n        return shiftEventTime(scheduleTime, terms.businessDayConvention, terms.calendar);\n    }\n\n    /**\n     * @notice Returns the epoch offset for a given event type to determine the\n     * correct order of events if multiple events have the same timestamp\n     */\n    function getEpochOffset(EventType eventType)\n        public\n        pure\n        returns (uint256)\n    {\n        if (eventType == EventType.IED) return 20;\n        if (eventType == EventType.PR) return 25;\n        if (eventType == EventType.IP) return 30;\n        if (eventType == EventType.IPCI) return 40;\n        if (eventType == EventType.FP) return 50;\n        if (eventType == EventType.DV) return 60;\n        if (eventType == EventType.MR) return 80;\n        if (eventType == EventType.RRF) return 90;\n        if (eventType == EventType.RR) return 100;\n        if (eventType == EventType.SC) return 110;\n        if (eventType == EventType.IPCB) return 120;\n        if (eventType == EventType.PRD) return 130;\n        if (eventType == EventType.TD) return 140;\n        if (eventType == EventType.STD) return 150;\n        if (eventType == EventType.MD) return 160;\n        if (eventType == EventType.AD) return 950;\n        return 0;\n    }\n\n    /**\n     * @notice Applies a period in IP notation to a given timestamp\n     */\n    function getTimestampPlusPeriod(IP memory period, uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 newTimestamp;\n\n        if (period.p == P.D) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, period.i);\n        } else if (period.p == P.W) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, period.i * 7);\n        } else if (period.p == P.M) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, period.i);\n        } else if (period.p == P.Q) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, period.i * 3);\n        } else if (period.p == P.H) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, period.i * 6);\n        } else if (period.p == P.Y) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, period.i);\n        } else {\n            revert(\"Core.getTimestampPlusPeriod: ATTRIBUTE_NOT_FOUND\");\n        }\n\n        return newTimestamp;\n    }\n\n    /**\n     * @notice Checks if a timestamp is in a given range.\n     */\n    function isInSegment(\n        uint256 timestamp,\n        uint256 startTimestamp,\n        uint256 endTimestamp\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        if (startTimestamp > endTimestamp) return false;\n        if (startTimestamp <= timestamp && timestamp <= endTimestamp) return true;\n        return false;\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "pragma solidity ^0.6.0;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n\n        int __days = _day\n          - 32075\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n          - OFFSET19700101;\n\n        _days = uint(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}"
    },
    "@atpar/actus-solidity/contracts/Core/ACTUSTypes.sol": {
      "content": "pragma solidity ^0.6.4;\r\n\r\n\r\n/**\r\n * @title ACTUSTypes\r\n * @notice Contains all type definitions for ACTUS. See ACTUS-Dictionary for definitions\r\n */\r\ncontract ACTUSTypes {\r\n\r\n    // constants used throughout\r\n    uint256 constant public PRECISION = 18;\r\n    int256 constant public ONE_POINT_ZERO = 1 * 10 ** 18;\r\n    uint256 constant MAX_CYCLE_SIZE = 120;\r\n    uint256 constant MAX_EVENT_SCHEDULE_SIZE = 120;\r\n\r\n    // IPS\r\n    enum P {D, W, M, Q, H, Y} // P=[D=Days, W=Weeks, M=Months, Q=Quarters, H=Halfyear, Y=Year]\r\n    enum S {LONG, SHORT} // S=[+=long stub,- short stub, {} if S empty then - for short stub]\r\n    struct IPS {\r\n        uint256 i; // I=Integer\r\n        P p;\r\n        S s;\r\n        bool isSet;\r\n    }\r\n\r\n    struct IP {\r\n        uint256 i;\r\n        P p;\r\n        bool isSet;\r\n    }\r\n\r\n    //               0    1   2   3   4    5   6   7   8     9  10   11  12  13   14  15  16  17    18  19  20   21  22\r\n    enum EventType {NE, IED, FP, PR, PD, PRF, PY, PP, IP, IPCI, CE, RRF, RR, DV, PRD, MR, TD, SC, IPCB, MD, XD, STD, AD}\r\n    enum Calendar {NC, MF}\r\n    enum BusinessDayConvention {NOS, SCF, SCMF, CSF, CSMF, SCP, SCMP, CSP, CSMP}\r\n    enum ClearingHouse {Y, N}\r\n    enum ContractRole {RPA, RPL, RFL, PFL, RF, PF, BUY, SEL, COL, CNO, UDL, UDLP, UDLM}\r\n    enum ContractPerformance {PF, DL, DQ, DF, MD, TD}\r\n    enum ContractType {PAM, ANN, NAM, LAM, LAX, CLM, UMP, CSH, STK, COM, SWAPS, SWPPV, FXOUT, CAPFL, FUTUR, OPTNS, CEG, CEC} // required ?\r\n    enum CyclePointOfInterestPayment {B, E} // or E, B?\r\n    enum CyclePointOfRateReset {B, E}\r\n    enum DayCountConvention {AA, A360, A365, _30E360ISDA, _30E360, _28E336}\r\n    enum EndOfMonthConvention {SD, EOM}\r\n    enum FeeBasis {A, N}\r\n    enum InterestCalculationBase {NT, NTIED, NTL}\r\n    enum OptionExerciseType {E, B, A}\r\n    enum OptionType {C, P, CP}\r\n    enum PenaltyType {O, A, N, I}\r\n    enum PrepaymentEffect {N, A, M}\r\n    enum ScalingEffect {_000, I00, _0N0, IN0}\r\n    enum Seniority {S, J}\r\n    enum Unit {BRL, BSH, GLN, CUU, MWH, PND, STN, TON, TRO}\r\n    enum ContractReferenceType {CNT, CID, MOC, EID, CST}\r\n    enum ContractReferenceRole {UDL, FIL, SEL, COVE, COVI}\r\n\r\n    struct ContractReference {\r\n        bytes32 object;\r\n        ContractReferenceType _type;\r\n        ContractReferenceRole role;\r\n    }\r\n\r\n    struct State {\r\n        ContractPerformance contractPerformance;\r\n\r\n        uint256 statusDate;\r\n        uint256 nonPerformingDate;\r\n        uint256 maturityDate;\r\n        uint256 exerciseDate;\r\n        uint256 terminationDate;\r\n\r\n        int256 notionalPrincipal;\r\n        // int256 notionalPrincipal2;\r\n        int256 accruedInterest;\r\n        // int256 accruedInterest2;\r\n        int256 feeAccrued;\r\n        int256 nominalInterestRate;\r\n        // int256 nominalInterestRate2;\r\n        // int256 interestCalculationBaseAmount;\r\n        int256 interestScalingMultiplier;\r\n        int256 notionalScalingMultiplier;\r\n        int256 nextPrincipalRedemptionPayment;\r\n        int256 exerciseAmount;\r\n    }\r\n\r\n    // subset of the ACTUS terms object\r\n    // contains only attributes which are used in POFs and STFs\r\n    struct LifecycleTerms {\r\n        Calendar calendar;\r\n        ContractRole contractRole;\r\n        DayCountConvention dayCountConvention;\r\n        BusinessDayConvention businessDayConvention;\r\n        EndOfMonthConvention endOfMonthConvention;\r\n        ScalingEffect scalingEffect;\r\n        PenaltyType penaltyType;\r\n        FeeBasis feeBasis;\r\n        ContractPerformance creditEventTypeCovered;\r\n\r\n        address currency;\r\n        address settlementCurrency;\r\n\r\n        bytes32 marketObjectCodeRateReset;\r\n\r\n        uint256 statusDate;\r\n        uint256 maturityDate;\r\n\r\n        int256 notionalPrincipal;\r\n        int256 nominalInterestRate;\r\n        int256 feeAccrued;\r\n        int256 accruedInterest;\r\n        int256 rateMultiplier;\r\n        int256 rateSpread;\r\n        int256 feeRate;\r\n        int256 nextResetRate;\r\n        int256 penaltyRate;\r\n        int256 premiumDiscountAtIED;\r\n        int256 priceAtPurchaseDate;\r\n        int256 nextPrincipalRedemptionPayment;\r\n        int256 coverageOfCreditEnhancement;\r\n        int256 lifeCap;\r\n        int256 lifeFloor;\r\n        int256 periodCap;\r\n        int256 periodFloor;\r\n\r\n        IP gracePeriod;\r\n        IP delinquencyPeriod;\r\n\r\n        // for simplification since terms are limited only two contract references\r\n        // - make ContractReference top level and skip ContractStructure\r\n        ContractReference contractReference_1;\r\n        ContractReference contractReference_2;\r\n    }\r\n\r\n    // subset of the ACTUS terms object\r\n    // contains only attributes which are used in the schedule generation\r\n    struct GeneratingTerms {\r\n        ScalingEffect scalingEffect;\r\n\r\n        uint256 contractDealDate;\r\n        uint256 statusDate;\r\n        uint256 initialExchangeDate;\r\n        uint256 maturityDate;\r\n        uint256 purchaseDate;\r\n        uint256 capitalizationEndDate;\r\n        uint256 cycleAnchorDateOfInterestPayment;\r\n        uint256 cycleAnchorDateOfRateReset;\r\n        uint256 cycleAnchorDateOfScalingIndex;\r\n        uint256 cycleAnchorDateOfFee;\r\n        uint256 cycleAnchorDateOfPrincipalRedemption;\r\n\r\n        IPS cycleOfInterestPayment;\r\n        IPS cycleOfRateReset;\r\n        IPS cycleOfScalingIndex;\r\n        IPS cycleOfFee;\r\n        IPS cycleOfPrincipalRedemption;\r\n\r\n        IP gracePeriod;\r\n        IP delinquencyPeriod;\r\n    }\r\n\r\n    // ACTUS terms object\r\n    struct Terms {\r\n        ContractType contractType;\r\n        Calendar calendar;\r\n        ContractRole contractRole;\r\n        DayCountConvention dayCountConvention;\r\n        BusinessDayConvention businessDayConvention;\r\n        EndOfMonthConvention endOfMonthConvention;\r\n        ScalingEffect scalingEffect;\r\n        PenaltyType penaltyType;\r\n        FeeBasis feeBasis;\r\n        ContractPerformance creditEventTypeCovered;\r\n\r\n        address currency;\r\n        address settlementCurrency;\r\n\r\n        bytes32 marketObjectCodeRateReset;\r\n\r\n        uint256 contractDealDate;\r\n        uint256 statusDate;\r\n        uint256 initialExchangeDate;\r\n        uint256 maturityDate;\r\n        uint256 purchaseDate;\r\n        uint256 capitalizationEndDate;\r\n        uint256 cycleAnchorDateOfInterestPayment;\r\n        uint256 cycleAnchorDateOfRateReset;\r\n        uint256 cycleAnchorDateOfScalingIndex;\r\n        uint256 cycleAnchorDateOfFee;\r\n        uint256 cycleAnchorDateOfPrincipalRedemption;\r\n\r\n        int256 notionalPrincipal;\r\n        int256 nominalInterestRate;\r\n        int256 feeAccrued;\r\n        int256 accruedInterest;\r\n        int256 rateMultiplier;\r\n        int256 rateSpread;\r\n        int256 feeRate;\r\n        int256 nextResetRate;\r\n        int256 penaltyRate;\r\n        int256 premiumDiscountAtIED;\r\n        int256 priceAtPurchaseDate;\r\n        int256 nextPrincipalRedemptionPayment;\r\n        int256 coverageOfCreditEnhancement;\r\n        int256 lifeCap;\r\n        int256 lifeFloor;\r\n        int256 periodCap;\r\n        int256 periodFloor;\r\n\r\n        IPS cycleOfInterestPayment;\r\n        IPS cycleOfRateReset;\r\n        IPS cycleOfScalingIndex;\r\n        IPS cycleOfFee;\r\n        IPS cycleOfPrincipalRedemption;\r\n\r\n        IP gracePeriod;\r\n        IP delinquencyPeriod;\r\n\r\n        // for simplification since terms are limited only two contract references\r\n        // - make ContractReference top level and skip ContractStructure\r\n        ContractReference contractReference_1;\r\n        ContractReference contractReference_2;\r\n    }\r\n}\r\n"
    },
    "@atpar/actus-solidity/contracts/Core/Conventions/BusinessDayConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title BusinessDayConvention\n * @notice Contains conventions of how to handle non-business days when generating schedules of events.\n * The events schedule time can be shifted or not, if shifted it is possible that it is shifted to the next\n * or previous valid business days, etc.\n */\ncontract BusinessDayConvention is ACTUSTypes {\n\n    /**\n     * @notice Used in POFs and STFs for DCFs.\n     * No shifting is applied if a Calc/Shift instead of Shift/Calc BDC is provided.\n     */\n    function shiftCalcTime(\n        uint256 timestamp,\n        BusinessDayConvention convention,\n        Calendar calendar\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        if (\n            convention == BusinessDayConvention.CSF ||\n            convention == BusinessDayConvention.CSMF ||\n            convention == BusinessDayConvention.CSP ||\n            convention == BusinessDayConvention.CSMP\n        ) {\n            return timestamp;\n        }\n\n        return shiftEventTime(timestamp, convention, calendar);\n    }\n\n    /*\n     * @notice Used for generating event schedules (for single events and event cycles schedules).\n     * This convention assumes that when shifting the events schedule time according\n     * to a BDC, the time is shifted first and calculations are performed thereafter.\n     * (Calculations in POFs and STFs are based on the shifted time as well)\n     */\n    function shiftEventTime(\n        uint256 timestamp,\n        BusinessDayConvention convention,\n        Calendar calendar\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // Shift/Calc Following, Calc/Shift following\n        if (convention == BusinessDayConvention.SCF || convention == BusinessDayConvention.CSF) {\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n        // Shift/Calc Modified Following, Calc/Shift Modified following\n        // Same as unmodified if shifted date is in the same month, if not it returns the previous buiness-day\n        } else if (convention == BusinessDayConvention.SCMF || convention == BusinessDayConvention.CSMF) {\n            uint256 followingOrSameBusinessDay = getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n            if (BokkyPooBahsDateTimeLibrary.getMonth(followingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\n                return followingOrSameBusinessDay;\n            }\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n        // Shift/Calc Preceeding, Calc/Shift Preceeding\n        } else if (convention == BusinessDayConvention.SCP || convention == BusinessDayConvention.CSP) {\n            return getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n        // Shift/Calc Modified Preceeding, Calc/Shift Modified Preceeding\n        // Same as unmodified if shifted date is in the same month, if not it returns the following buiness-day\n        } else if (convention == BusinessDayConvention.SCMP || convention == BusinessDayConvention.CSMP) {\n            uint256 preceedingOrSameBusinessDay = getClosestBusinessDaySameDayOrPreceeding(timestamp, calendar);\n            if (BokkyPooBahsDateTimeLibrary.getMonth(preceedingOrSameBusinessDay) == BokkyPooBahsDateTimeLibrary.getMonth(timestamp)) {\n                return preceedingOrSameBusinessDay;\n            }\n            return getClosestBusinessDaySameDayOrFollowing(timestamp, calendar);\n        }\n\n        return timestamp;\n    }\n\n    /**\n     * @notice Returns the following business day if a non-business day is provided.\n     * (Returns the same day if calendar != MondayToFriday)\n     */\n    function getClosestBusinessDaySameDayOrFollowing(uint256 timestamp, Calendar calendar)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (calendar == Calendar.MF) {\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 2);\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\n                return BokkyPooBahsDateTimeLibrary.addDays(timestamp, 1);\n            }\n        }\n        return timestamp;\n    }\n\n    /**\n     * @notice Returns the previous buiness day if a non-businessday is provided.\n     * (Returns the same day if calendar != MondayToFriday)\n     */\n    function getClosestBusinessDaySameDayOrPreceeding(uint256 timestamp, Calendar calendar)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (calendar == Calendar.MF) {\n            if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 6) {\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 1);\n            } else if (BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp) == 7) {\n                return BokkyPooBahsDateTimeLibrary.subDays(timestamp, 2);\n            }\n        }\n        return timestamp;\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Engines/IEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/ACTUSTypes.sol\";\n\n\n/**\n * @title IEngine\n * @notice Interface which all Engines have to implement\n */\nabstract contract IEngine is ACTUSTypes {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        virtual\n        returns (State memory);\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        virtual\n        returns (State memory);\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        virtual\n        returns (int256);\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        virtual\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory);\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        virtual\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory);\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        virtual\n        returns (bool);\n}\n"
    },
    "contracts/Core/SharedTypes.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"@atpar/actus-solidity/contracts/Core/ACTUSTypes.sol\";\n\n\ncontract SharedTypes is ACTUSTypes {\n\n    // offset == 0 is interpreted as a not set date value and not shifted\n    // hence we define 1 as an offset == anchorDate\n    uint256 constant ZERO_OFFSET = 1;\n\n    struct TemplateSchedule {\n        // scheduleTime and EventType are tighlty packed and encoded as bytes32\n        // in the context of a Template scheduleTime is defined as an offset in seconds\n        // respective to an anchorDate which is defined in the CustomTerms of the asset which references this template\n        // index of event => bytes32 encoded event\n        mapping(uint256 => bytes32) events;\n        // the length of the schedule, used to determine the end of the schedule\n        uint256 length;\n    }\n\n    struct AssetOwnership {\n        // account which has to fulfill all obligations for the creator side\n        address creatorObligor;\n        // account to which all cashflows to which the creator is the beneficiary are forwarded\n        address creatorBeneficiary;\n        // account which has to fulfill all obligations for the counterparty\n        address counterpartyObligor;\n        // account to which all cashflows to which the counterparty is the beneficiary are forwarded\n        address counterpartyBeneficiary;\n    }\n\n    // modified set of LifecycleTerms which does not contain ContractReferences\n    struct TemplateTerms {\n        Calendar calendar;\n        ContractRole contractRole;\n        DayCountConvention dayCountConvention;\n        BusinessDayConvention businessDayConvention;\n        EndOfMonthConvention endOfMonthConvention;\n        ScalingEffect scalingEffect;\n        PenaltyType penaltyType;\n        FeeBasis feeBasis;\n        ContractPerformance creditEventTypeCovered;\n\n        address currency;\n        address settlementCurrency;\n\n        bytes32 marketObjectCodeRateReset;\n\n        // in the context of a Template date values are defined as offsets in seconds\n        // respective to and anchorDate which is defined in the CustomTerms of the asset which references this template\n        // if set == 0 offset is interpreted as a not set date value (see ZERO_OFFSET)\n        uint256 statusDateOffset;\n        uint256 maturityDateOffset;\n\n        int256 notionalPrincipal;\n        int256 nominalInterestRate;\n        int256 feeAccrued;\n        int256 accruedInterest;\n        int256 rateMultiplier;\n        int256 rateSpread;\n        int256 feeRate;\n        int256 nextResetRate;\n        int256 penaltyRate;\n        int256 premiumDiscountAtIED;\n        int256 priceAtPurchaseDate;\n        int256 nextPrincipalRedemptionPayment;\n        int256 coverageOfCreditEnhancement;\n        int256 lifeCap;\n        int256 lifeFloor;\n        int256 periodCap;\n        int256 periodFloor;\n\n        IP gracePeriod;\n        IP delinquencyPeriod;\n    }\n\n    struct CustomTerms {\n        uint256 anchorDate;\n        // set of boolean values, true indicating that attribute is overwritten,\n        // bit position from right to left in uint256 := position in lifecycleTerms (contractReference are always overwritten)\n        // e.g. 0010110000...\n        uint256 overwrittenAttributesMap;\n        // terms object containing overwritten values\n        LifecycleTerms overwrittenTerms;\n    }\n}\n"
    },
    "contracts/Core/ScheduleUtils.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"./SharedTypes.sol\";\n\n\ncontract ScheduleUtils is SharedTypes {\n\n    function isUnscheduledEventType(EventType eventType)\n        internal\n        pure\n        returns (bool)\n    {\n        if (eventType == EventType.CE || eventType == EventType.XD) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function isCyclicEventType(EventType eventType)\n        internal\n        pure\n        returns (bool)\n    {\n        if (\n            eventType == EventType.IP\n            || eventType == EventType.IPCI\n            || eventType == EventType.PR\n            || eventType == EventType.SC\n            || eventType == EventType.RR\n            || eventType == EventType.PY\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n}"
    },
    "contracts/Core/Conversions.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./SharedTypes.sol\";\n\n\ncontract Conversions is SharedTypes {\n\n    function deriveLifecycleTermsFromCustomTermsAndTemplateTerms(\n        TemplateTerms memory templateTerms,\n        CustomTerms memory terms\n    )\n        public\n        pure\n        returns (LifecycleTerms memory)\n    {\n        return LifecycleTerms(\n            isOverwritten(terms.overwrittenAttributesMap, 0) ? terms.overwrittenTerms.calendar : templateTerms.calendar,\n            isOverwritten(terms.overwrittenAttributesMap, 1) ? terms.overwrittenTerms.contractRole : templateTerms.contractRole,\n            isOverwritten(terms.overwrittenAttributesMap, 2) ? terms.overwrittenTerms.dayCountConvention : templateTerms.dayCountConvention,\n            isOverwritten(terms.overwrittenAttributesMap, 3) ? terms.overwrittenTerms.businessDayConvention : templateTerms.businessDayConvention,\n            isOverwritten(terms.overwrittenAttributesMap, 4) ? terms.overwrittenTerms.endOfMonthConvention : templateTerms.endOfMonthConvention,\n            isOverwritten(terms.overwrittenAttributesMap, 5) ? terms.overwrittenTerms.scalingEffect : templateTerms.scalingEffect,\n            isOverwritten(terms.overwrittenAttributesMap, 6) ? terms.overwrittenTerms.penaltyType : templateTerms.penaltyType,\n            isOverwritten(terms.overwrittenAttributesMap, 7) ? terms.overwrittenTerms.feeBasis : templateTerms.feeBasis,\n            isOverwritten(terms.overwrittenAttributesMap, 8) ? terms.overwrittenTerms.creditEventTypeCovered : templateTerms.creditEventTypeCovered,\n\n            isOverwritten(terms.overwrittenAttributesMap, 9) ? terms.overwrittenTerms.currency : templateTerms.currency,\n            isOverwritten(terms.overwrittenAttributesMap, 10) ? terms.overwrittenTerms.settlementCurrency : templateTerms.settlementCurrency,\n\n            isOverwritten(terms.overwrittenAttributesMap, 11) ? terms.overwrittenTerms.marketObjectCodeRateReset : templateTerms.marketObjectCodeRateReset,\n\n            isOverwritten(terms.overwrittenAttributesMap, 12) ? terms.overwrittenTerms.statusDate : applyAnchorDateToOffset(terms.anchorDate, templateTerms.statusDateOffset),\n            isOverwritten(terms.overwrittenAttributesMap, 13) ? terms.overwrittenTerms.maturityDate : applyAnchorDateToOffset(terms.anchorDate, templateTerms.maturityDateOffset),\n\n            isOverwritten(terms.overwrittenAttributesMap, 14) ? terms.overwrittenTerms.notionalPrincipal : templateTerms.notionalPrincipal,\n            isOverwritten(terms.overwrittenAttributesMap, 15) ? terms.overwrittenTerms.nominalInterestRate : templateTerms.nominalInterestRate,\n            isOverwritten(terms.overwrittenAttributesMap, 16) ? terms.overwrittenTerms.feeAccrued : templateTerms.feeAccrued,\n            isOverwritten(terms.overwrittenAttributesMap, 17) ? terms.overwrittenTerms.accruedInterest : templateTerms.accruedInterest,\n            isOverwritten(terms.overwrittenAttributesMap, 18) ? terms.overwrittenTerms.rateMultiplier : templateTerms.rateMultiplier,\n            isOverwritten(terms.overwrittenAttributesMap, 19) ? terms.overwrittenTerms.rateSpread : templateTerms.rateSpread,\n            isOverwritten(terms.overwrittenAttributesMap, 20) ? terms.overwrittenTerms.feeRate : templateTerms.feeRate,\n            isOverwritten(terms.overwrittenAttributesMap, 21) ? terms.overwrittenTerms.nextResetRate : templateTerms.nextResetRate,\n            isOverwritten(terms.overwrittenAttributesMap, 22) ? terms.overwrittenTerms.penaltyRate : templateTerms.penaltyRate,\n            isOverwritten(terms.overwrittenAttributesMap, 23) ? terms.overwrittenTerms.premiumDiscountAtIED : templateTerms.premiumDiscountAtIED,\n            isOverwritten(terms.overwrittenAttributesMap, 24) ? terms.overwrittenTerms.priceAtPurchaseDate : templateTerms.priceAtPurchaseDate,\n            isOverwritten(terms.overwrittenAttributesMap, 25) ? terms.overwrittenTerms.nextPrincipalRedemptionPayment : templateTerms.nextPrincipalRedemptionPayment,\n            isOverwritten(terms.overwrittenAttributesMap, 26) ? terms.overwrittenTerms.coverageOfCreditEnhancement : templateTerms.coverageOfCreditEnhancement,\n            isOverwritten(terms.overwrittenAttributesMap, 27) ? terms.overwrittenTerms.lifeCap : templateTerms.lifeCap,\n            isOverwritten(terms.overwrittenAttributesMap, 28) ? terms.overwrittenTerms.lifeFloor : templateTerms.lifeFloor,\n            isOverwritten(terms.overwrittenAttributesMap, 29) ? terms.overwrittenTerms.periodCap : templateTerms.periodCap,\n            isOverwritten(terms.overwrittenAttributesMap, 30) ? terms.overwrittenTerms.periodFloor : templateTerms.periodFloor,\n\n            isOverwritten(terms.overwrittenAttributesMap, 31) ? terms.overwrittenTerms.gracePeriod : templateTerms.gracePeriod,\n            isOverwritten(terms.overwrittenAttributesMap, 32) ? terms.overwrittenTerms.delinquencyPeriod : templateTerms.delinquencyPeriod,\n\n            terms.overwrittenTerms.contractReference_1, // mandatory custom terms attribute\n            terms.overwrittenTerms.contractReference_2 // mandatory custom terms attribute\n        );\n    }\n\n    function encodeCollateralAsObject(address collateralToken, uint256 collateralAmount)\n        public\n        pure\n        returns (bytes32)\n    {\n        return bytes32(uint256(uint160(collateralToken))) << 96 | bytes32(uint256(uint96(collateralAmount)));\n    }\n\n    function decodeCollateralObject(bytes32 object)\n        public\n        pure\n        returns (address, uint256)\n    {\n        return (\n            address(uint160(uint256(object >> 96))),\n            uint256(uint96(uint256(object)))\n        );\n    }\n\n    function applyAnchorDateToOffset(uint256 anchorDate, uint256 offset)\n        internal\n        pure\n        returns (uint256)\n    {\n        // interpret offset == 0 as a not set date value, only shift by anchorDate if offset > 0\n        if (offset == 0) return 0;\n        // offset == ZERO_OFFSET indicating that offset is set and equal to anchorDate\n        if (offset == ZERO_OFFSET) return anchorDate;\n        // if offset != ZERO_OFFSET, shift offset by anchorDate\n        return anchorDate + offset;\n    }\n\n    function isOverwritten (uint256 overwrittenAttributesMap, uint256 attributeIndex) internal pure returns (bool) {\n        return (overwrittenAttributesMap >> attributeIndex & 1) == 1;\n    }\n}\n"
    },
    "contracts/Core/AssetRegistry/IAssetRegistry.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./AssetRegistryStorage.sol\";\n\n\nabstract contract IAssetRegistry is AssetRegistryStorage {\n\n    function isRegistered(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (bool);\n\n    function setCreatorObligor (bytes32 assetId, address newCreatorObligor)\n        external\n        virtual;\n\n    function setCounterpartyObligor (bytes32 assetId, address newCounterpartyObligor)\n        external\n        virtual;\n\n    function setCreatorBeneficiary(bytes32 assetId, address newCreatorBeneficiary)\n        external\n        virtual;\n\n    function setCounterpartyBeneficiary(bytes32 assetId, address newCounterpartyBeneficiary)\n        external\n        virtual;\n\n    function setBeneficiaryForCashflowId(bytes32 assetId, int8 cashflowId, address beneficiary)\n        external\n        virtual;\n\n    function getOwnership(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (AssetOwnership memory);\n\n    function getCashflowBeneficiary(bytes32 assetId, int8 cashflowId)\n        external\n        view\n        virtual\n        returns (address);\n\n    function getTerms(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (LifecycleTerms memory);\n\n    function getState(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (State memory);\n\n    function getFinalizedState(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (State memory);\n\n    function getAnchorDate(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function getEngine(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (address);\n\n    function getActor(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (address);\n\n    function getTemplateId(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (bytes32);\n\n    function getPendingEvent (bytes32 assetId)\n        external\n        view\n        virtual\n        returns (bytes32);\n\n    function pushPendingEvent (bytes32 assetId, bytes32 pendingEvent)\n        external\n        virtual;\n\n    function popPendingEvent (bytes32 assetId)\n        external\n        virtual\n        returns (bytes32);\n\n    function getNextUnderlyingEvent (bytes32 assetId)\n        external\n        view\n        virtual\n        returns (bytes32);\n\n    function getNextScheduleIndex(bytes32 assetId)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function getNextScheduledEvent (bytes32 assetId)\n        external\n        view\n        virtual\n        returns (bytes32);\n\n    function popNextScheduledEvent(bytes32 assetId)\n        external\n        virtual\n        returns (bytes32);\n\n    function setState(bytes32 assetId, State memory state)\n        public\n        virtual;\n\n    function setFinalizedState(bytes32 assetId, State memory state)\n        public\n        virtual;\n\n    function setCustomTerms(bytes32 assetId, CustomTerms memory terms)\n        public\n        virtual;\n    \n    function setAnchorDate(bytes32 assetId, uint256 anchorDate)\n        public\n        virtual;\n\n    function setEngine(bytes32 assetId, address engine)\n        public\n        virtual;\n\n    function setActor(bytes32 assetId, address actor)\n        public\n        virtual;\n\n    function registerAsset(\n        bytes32 assetId,\n        AssetOwnership memory ownership,\n        bytes32 templateId,\n        CustomTerms memory customTerms,\n        State memory state,\n        address engine,\n        address actor,\n        address root\n    )\n        public\n        virtual;\n\n    function hasAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        public\n        virtual\n        returns (bool);\n\n    function hasRootAccess(bytes32 assetId, address account)\n        public\n        virtual\n        returns (bool);\n\n    function grantAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        public\n        virtual;\n\n    function revokeAccess(bytes32 assetId, bytes4 methodSignature, address account)\n        public\n        virtual;\n}\n"
    },
    "contracts/Core/AssetRegistry/AssetRegistryStorage.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"@atpar/actus-solidity/contracts/Core/Utils.sol\";\n\nimport \"../TemplateRegistry/ITemplateRegistry.sol\";\nimport \"../Conversions.sol\";\nimport \"../SharedTypes.sol\";\n\n\n/**\n * @title AssetRegistryStorage\n * @notice Describes the storage of the AssetRegistry\n * Contains getter and setter methods for encoding, decoding data to optimize gas cost.\n * Circumvents storing default values by relying on the characteristic of mappings returning zero for not set values.\n */\ncontract AssetRegistryStorage is SharedTypes, Utils, Conversions {\n\n    struct Asset {\n        // boolean indicating that asset exists / is registered\n        bool isSet;\n        // Id of template registered in the TemplateRegistry\n        bytes32 templateId;\n        // last event which could not be settled\n        bytes32 pendingEvent;\n        // pointer to index of the next event in the template schedule\n        uint256 nextScheduleIndex;\n        // binary encoded map of the LifecycleTerms attributes which overwrite the values defined in TemplateTerms\n        uint256 overwrittenAttributesMap;\n        // address of the ACTUS Engine used for computing the State and the Payoff of the asset\n        address engine;\n        // address of the Asset Actor which is allowed to update the State of the asset\n        address actor;\n        // ownership of the asset\n        AssetOwnership ownership;\n        // granular ownership of the event type specific cashflows\n        // per default owners are beneficiaries defined in ownership object\n        // cashflow id (:= (EventType index + 1) * direction) => owner\n        mapping (int8 => address) cashflowBeneficiaries;\n        // method level access control - stores which address can a specific method\n        // method signature => address => has access\n        mapping (bytes4 => mapping (address => bool)) access;\n        // tightly packed, encoded LifecycleTerms and State values of the asset\n        // bytes32(0) used as default value for each attribute\n        // storage id => bytes32 encoded value\n        mapping (uint8 => bytes32) packedTermsState;\n    }\n\n    // AssetId => Asset\n    mapping (bytes32 => Asset) assets;\n\n    ITemplateRegistry public templateRegistry;\n\n\n    constructor(ITemplateRegistry _templateRegistry) public {\n        templateRegistry = _templateRegistry;\n    }\n\n    /**\n     * @dev Store asset data by efficiently storing the CustomTerms and the inital State of the asset\n     */\n    function setAsset(\n        bytes32 _assetId,\n        AssetOwnership memory _ownership,\n        bytes32 _templateId,\n        CustomTerms memory customTerms,\n        State memory state,\n        address _engine,\n        address _actor\n    )\n        internal\n    {\n        assets[_assetId] = Asset({\n            isSet: true,\n            templateId: _templateId,\n            pendingEvent: bytes32(0),\n            nextScheduleIndex: 0,\n            overwrittenAttributesMap: customTerms.overwrittenAttributesMap,\n            engine: _engine,\n            actor: _actor,\n            ownership: _ownership\n        });\n\n        encodeAndSetTerms(_assetId, customTerms);\n        encodeAndSetState(_assetId, state);\n        encodeAndSetFinalizedState(_assetId, state);\n    }\n\n    /**\n     * @dev Encode and set the anchorDate of the customTerms\n     */\n    function encodeAndSetAnchorDate(bytes32 assetId, uint256 anchorDate) internal {\n        assets[assetId].packedTermsState[1] = bytes32(anchorDate);\n    }\n\n    /**\n     * @dev Tightly pack and store only non-zero overwritten terms (LifecycleTerms)\n     * @notice All non zero values of the overwrittenTerms object are stored.\n     * It does not check if overwrittenAttributesMap actually marks attribute as overwritten.\n     */\n    function encodeAndSetTerms(bytes32 assetId, CustomTerms memory customTerms) internal {\n        assets[assetId].packedTermsState[1] = bytes32(customTerms.anchorDate);\n\n        bytes32 enums =\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.calendar))) << 240 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.contractRole))) << 232 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.scalingEffect))) << 200 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.penaltyType))) << 192 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.feeBasis))) << 184 |\n            bytes32(uint256(uint8(customTerms.overwrittenTerms.creditEventTypeCovered))) << 176;\n\n        if (enums != bytes32(0)) assets[assetId].packedTermsState[2] = enums;\n\n        if (customTerms.overwrittenTerms.currency != address(0)) assets[assetId].packedTermsState[3] = bytes32(uint256(customTerms.overwrittenTerms.currency) << 96);\n        if (customTerms.overwrittenTerms.settlementCurrency != address(0)) assets[assetId].packedTermsState[4] = bytes32(uint256(customTerms.overwrittenTerms.settlementCurrency) << 96);\n\n        if (customTerms.overwrittenTerms.marketObjectCodeRateReset != bytes32(0)) assets[assetId].packedTermsState[5] = bytes32(customTerms.overwrittenTerms.marketObjectCodeRateReset);\n\n        if (customTerms.overwrittenTerms.statusDate != uint256(0)) assets[assetId].packedTermsState[6] = bytes32(customTerms.overwrittenTerms.statusDate);\n        if (customTerms.overwrittenTerms.maturityDate != uint256(0)) assets[assetId].packedTermsState[7] = bytes32(customTerms.overwrittenTerms.maturityDate);\n\n        if (customTerms.overwrittenTerms.notionalPrincipal != int256(0)) assets[assetId].packedTermsState[8] = bytes32(customTerms.overwrittenTerms.notionalPrincipal);\n        if (customTerms.overwrittenTerms.nominalInterestRate != int256(0)) assets[assetId].packedTermsState[9] = bytes32(customTerms.overwrittenTerms.nominalInterestRate);\n        if (customTerms.overwrittenTerms.feeAccrued != int256(0)) assets[assetId].packedTermsState[10] = bytes32(customTerms.overwrittenTerms.feeAccrued);\n        if (customTerms.overwrittenTerms.accruedInterest != int256(0)) assets[assetId].packedTermsState[11] = bytes32(customTerms.overwrittenTerms.accruedInterest);\n        if (customTerms.overwrittenTerms.rateMultiplier != int256(0)) assets[assetId].packedTermsState[12] = bytes32(customTerms.overwrittenTerms.rateMultiplier);\n        if (customTerms.overwrittenTerms.rateSpread != int256(0)) assets[assetId].packedTermsState[13] = bytes32(customTerms.overwrittenTerms.rateSpread);\n        if (customTerms.overwrittenTerms.feeRate != int256(0)) assets[assetId].packedTermsState[14] = bytes32(customTerms.overwrittenTerms.feeRate);\n        if (customTerms.overwrittenTerms.nextResetRate != int256(0)) assets[assetId].packedTermsState[15] = bytes32(customTerms.overwrittenTerms.nextResetRate);\n        if (customTerms.overwrittenTerms.penaltyRate != int256(0)) assets[assetId].packedTermsState[16] = bytes32(customTerms.overwrittenTerms.penaltyRate);\n        if (customTerms.overwrittenTerms.premiumDiscountAtIED != int256(0)) assets[assetId].packedTermsState[17] = bytes32(customTerms.overwrittenTerms.premiumDiscountAtIED);\n        if (customTerms.overwrittenTerms.priceAtPurchaseDate != int256(0)) assets[assetId].packedTermsState[18] = bytes32(customTerms.overwrittenTerms.priceAtPurchaseDate);\n        if (customTerms.overwrittenTerms.nextPrincipalRedemptionPayment != int256(0)) assets[assetId].packedTermsState[19] = bytes32(customTerms.overwrittenTerms.nextPrincipalRedemptionPayment);\n        if (customTerms.overwrittenTerms.coverageOfCreditEnhancement != int256(0)) assets[assetId].packedTermsState[20] = bytes32(customTerms.overwrittenTerms.coverageOfCreditEnhancement);\n        if (customTerms.overwrittenTerms.lifeCap != int256(0)) assets[assetId].packedTermsState[21] = bytes32(customTerms.overwrittenTerms.lifeCap);\n        if (customTerms.overwrittenTerms.lifeFloor != int256(0)) assets[assetId].packedTermsState[22] = bytes32(customTerms.overwrittenTerms.lifeFloor);\n        if (customTerms.overwrittenTerms.periodCap != int256(0)) assets[assetId].packedTermsState[23] = bytes32(customTerms.overwrittenTerms.periodCap);\n        if (customTerms.overwrittenTerms.periodFloor != int256(0)) assets[assetId].packedTermsState[24] = bytes32(customTerms.overwrittenTerms.periodFloor);\n\n        if (customTerms.overwrittenTerms.gracePeriod.isSet) {\n            assets[assetId].packedTermsState[25] =\n                bytes32(uint256(customTerms.overwrittenTerms.gracePeriod.i)) << 24 |\n                bytes32(uint256(customTerms.overwrittenTerms.gracePeriod.p)) << 16 |\n                bytes32(uint256(1)) << 8;\n        }\n        if (customTerms.overwrittenTerms.delinquencyPeriod.isSet) {\n            assets[assetId].packedTermsState[26] =\n                bytes32(uint256(customTerms.overwrittenTerms.delinquencyPeriod.i)) << 24 |\n                bytes32(uint256(customTerms.overwrittenTerms.delinquencyPeriod.p)) << 16 |\n                bytes32(uint256(1)) << 8;\n        }\n\n        if (customTerms.overwrittenTerms.contractReference_1.object != bytes32(0)) {\n            assets[assetId].packedTermsState[27] = bytes32(customTerms.overwrittenTerms.contractReference_1.object);\n            assets[assetId].packedTermsState[28] =\n                bytes32(uint256(customTerms.overwrittenTerms.contractReference_1._type)) << 16 |\n                bytes32(uint256(customTerms.overwrittenTerms.contractReference_1.role)) << 8;\n\n        }\n        if (customTerms.overwrittenTerms.contractReference_2.object != bytes32(0)) {\n            assets[assetId].packedTermsState[29] = bytes32(customTerms.overwrittenTerms.contractReference_2.object);\n            assets[assetId].packedTermsState[30] =\n                bytes32(uint256(customTerms.overwrittenTerms.contractReference_2._type)) << 16 |\n                bytes32(uint256(customTerms.overwrittenTerms.contractReference_2.role)) << 8;\n\n        }\n    }\n\n    /**\n     * @dev Tightly pack and store State\n     */\n    function encodeAndSetState(bytes32 assetId, State memory state) internal {\n        bytes32 enums =\n            bytes32(uint256(uint8(state.contractPerformance))) << 248;\n\n        if (enums != bytes32(0)) assets[assetId].packedTermsState[101] = enums;\n\n        if (state.statusDate != uint256(0)) assets[assetId].packedTermsState[102] = bytes32(state.statusDate);\n        if (state.nonPerformingDate != uint256(0)) assets[assetId].packedTermsState[103] = bytes32(state.nonPerformingDate);\n        if (state.maturityDate != uint256(0)) assets[assetId].packedTermsState[104] = bytes32(state.maturityDate);\n        if (state.exerciseDate != uint256(0)) assets[assetId].packedTermsState[105] = bytes32(state.exerciseDate);\n        if (state.terminationDate != uint256(0)) assets[assetId].packedTermsState[106] = bytes32(state.terminationDate);\n\n        if (state.notionalPrincipal != int256(0)) assets[assetId].packedTermsState[107] = bytes32(state.notionalPrincipal);\n        if (state.accruedInterest != int256(0)) assets[assetId].packedTermsState[108] = bytes32(state.accruedInterest);\n        if (state.feeAccrued != int256(0)) assets[assetId].packedTermsState[109] = bytes32(state.feeAccrued);\n        if (state.nominalInterestRate != int256(0)) assets[assetId].packedTermsState[110] = bytes32(state.nominalInterestRate);\n        if (state.interestScalingMultiplier != int256(0)) assets[assetId].packedTermsState[111] = bytes32(state.interestScalingMultiplier);\n        if (state.notionalScalingMultiplier != int256(0)) assets[assetId].packedTermsState[112] = bytes32(state.notionalScalingMultiplier);\n        // solium-disable-next-line\n        if (state.nextPrincipalRedemptionPayment != int256(0)) assets[assetId].packedTermsState[113] = bytes32(state.nextPrincipalRedemptionPayment);\n        if (state.exerciseAmount != int256(0)) assets[assetId].packedTermsState[114] = bytes32(state.exerciseAmount);\n    }\n\n    /**\n     * @dev Tightly pack and store finalized State\n     */\n    function encodeAndSetFinalizedState(bytes32 assetId, State memory state) internal {\n        bytes32 enums =\n            bytes32(uint256(uint8(state.contractPerformance))) << 248;\n\n        if (enums != bytes32(0)) assets[assetId].packedTermsState[151] = enums;\n\n        if (state.statusDate != uint256(0)) assets[assetId].packedTermsState[152] = bytes32(state.statusDate);\n        if (state.nonPerformingDate != uint256(0)) assets[assetId].packedTermsState[153] = bytes32(state.nonPerformingDate);\n        if (state.maturityDate != uint256(0)) assets[assetId].packedTermsState[154] = bytes32(state.maturityDate);\n        if (state.exerciseDate != uint256(0)) assets[assetId].packedTermsState[155] = bytes32(state.exerciseDate);\n        if (state.terminationDate != uint256(0)) assets[assetId].packedTermsState[156] = bytes32(state.terminationDate);\n\n        if (state.notionalPrincipal != int256(0)) assets[assetId].packedTermsState[157] = bytes32(state.notionalPrincipal);\n        if (state.accruedInterest != int256(0)) assets[assetId].packedTermsState[158] = bytes32(state.accruedInterest);\n        if (state.feeAccrued != int256(0)) assets[assetId].packedTermsState[159] = bytes32(state.feeAccrued);\n        if (state.nominalInterestRate != int256(0)) assets[assetId].packedTermsState[160] = bytes32(state.nominalInterestRate);\n        if (state.interestScalingMultiplier != int256(0)) assets[assetId].packedTermsState[161] = bytes32(state.interestScalingMultiplier);\n        if (state.notionalScalingMultiplier != int256(0)) assets[assetId].packedTermsState[162] = bytes32(state.notionalScalingMultiplier);\n        // solium-disable-next-line\n        if (state.nextPrincipalRedemptionPayment != int256(0)) assets[assetId].packedTermsState[163] = bytes32(state.nextPrincipalRedemptionPayment);\n        if (state.exerciseAmount != int256(0)) assets[assetId].packedTermsState[164] = bytes32(state.exerciseAmount);\n    }\n\n    /**\n     * @dev Decode and load the anchorDate of the customTerms\n     */\n    function decodeAndGetAnchorDate(bytes32 assetId) internal view returns (uint256) {\n        return uint256(assets[assetId].packedTermsState[1]);\n    }\n\n    /**\n     * @dev Decode and load overwritten Terms (LifecycleTerms) and return it as CustomTerms\n     */\n    function decodeAndGetTerms(bytes32 assetId) internal view returns (LifecycleTerms memory) {\n        // load templateTerms from TemplateRegistry\n        TemplateTerms memory templateTerms = templateRegistry.getTemplateTerms(assets[assetId].templateId);\n\n        CustomTerms memory customTerms = CustomTerms(\n            // load anchorDate\n            uint256(assets[assetId].packedTermsState[1]),\n            // laod map of overwritten attributes\n            assets[assetId].overwrittenAttributesMap,\n            // load overwritten values\n            LifecycleTerms(\n                Calendar(uint8(uint256(assets[assetId].packedTermsState[2] >> 240))),\n                ContractRole(uint8(uint256(assets[assetId].packedTermsState[2] >> 232))),\n                DayCountConvention(uint8(uint256(assets[assetId].packedTermsState[2] >> 224))),\n                BusinessDayConvention(uint8(uint256(assets[assetId].packedTermsState[2] >> 216))),\n                EndOfMonthConvention(uint8(uint256(assets[assetId].packedTermsState[2] >> 208))),\n                ScalingEffect(uint8(uint256(assets[assetId].packedTermsState[2] >> 200))),\n                PenaltyType(uint8(uint256(assets[assetId].packedTermsState[2] >> 192))),\n                FeeBasis(uint8(uint256(assets[assetId].packedTermsState[2] >> 184))),\n                ContractPerformance(uint8(uint256(assets[assetId].packedTermsState[2] >> 176))),\n\n                address(uint160(uint256(assets[assetId].packedTermsState[3]) >> 96)),\n                address(uint160(uint256(assets[assetId].packedTermsState[4]) >> 96)),\n\n                assets[assetId].packedTermsState[5],\n\n                uint256(assets[assetId].packedTermsState[6]),\n                uint256(assets[assetId].packedTermsState[7]),\n                int256(assets[assetId].packedTermsState[8]),\n                int256(assets[assetId].packedTermsState[9]),\n                int256(assets[assetId].packedTermsState[10]),\n                int256(assets[assetId].packedTermsState[11]),\n                int256(assets[assetId].packedTermsState[12]),\n                int256(assets[assetId].packedTermsState[13]),\n                int256(assets[assetId].packedTermsState[14]),\n                int256(assets[assetId].packedTermsState[15]),\n                int256(assets[assetId].packedTermsState[16]),\n                int256(assets[assetId].packedTermsState[17]),\n                int256(assets[assetId].packedTermsState[18]),\n                int256(assets[assetId].packedTermsState[19]),\n                int256(assets[assetId].packedTermsState[20]),\n                int256(assets[assetId].packedTermsState[21]),\n                int256(assets[assetId].packedTermsState[22]),\n                int256(assets[assetId].packedTermsState[23]),\n                int256(assets[assetId].packedTermsState[24]),\n\n                IP(\n                    uint256(assets[assetId].packedTermsState[25] >> 24),\n                    P(uint8(uint256(assets[assetId].packedTermsState[25] >> 16))),\n                    (assets[assetId].packedTermsState[25] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n                ),\n                IP(\n                    uint256(assets[assetId].packedTermsState[26] >> 24),\n                    P(uint8(uint256(assets[assetId].packedTermsState[26] >> 16))),\n                    (assets[assetId].packedTermsState[26] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n                ),\n                ContractReference(\n                    assets[assetId].packedTermsState[27],\n                    ContractReferenceType(uint8(uint256(assets[assetId].packedTermsState[28] >> 16))),\n                    ContractReferenceRole(uint8(uint256(assets[assetId].packedTermsState[28] >> 8)))\n                ),\n                ContractReference(\n                    assets[assetId].packedTermsState[29],\n                    ContractReferenceType(uint8(uint256(assets[assetId].packedTermsState[30] >> 16))),\n                    ContractReferenceRole(uint8(uint256(assets[assetId].packedTermsState[30] >> 8)))\n                )\n            )\n        );\n\n        // return LifecycleTerms of the asset by deriving it from the TemplateTerms and overwritten terms in CustomTerms\n        return deriveLifecycleTermsFromCustomTermsAndTemplateTerms(templateTerms, customTerms);\n    }\n\n    /**\n     * @dev Decode and load the State of the asset\n     */\n    function decodeAndGetState(bytes32 assetId) internal view returns (State memory) {\n        return State(\n            ContractPerformance(uint8(uint256(assets[assetId].packedTermsState[101] >> 248))),\n\n            uint256(assets[assetId].packedTermsState[102]),\n            uint256(assets[assetId].packedTermsState[103]),\n            uint256(assets[assetId].packedTermsState[104]),\n            uint256(assets[assetId].packedTermsState[105]),\n            uint256(assets[assetId].packedTermsState[106]),\n\n            int256(assets[assetId].packedTermsState[107]),\n            int256(assets[assetId].packedTermsState[108]),\n            int256(assets[assetId].packedTermsState[109]),\n            int256(assets[assetId].packedTermsState[110]),\n            int256(assets[assetId].packedTermsState[111]),\n            int256(assets[assetId].packedTermsState[112]),\n            int256(assets[assetId].packedTermsState[113]),\n            int256(assets[assetId].packedTermsState[114])\n        );\n    }\n\n    /**\n     * @dev Decode and load the finalized State of the asset\n     */\n    function decodeAndGetFinalizedState(bytes32 assetId) internal view returns (State memory) {\n        return State(\n            ContractPerformance(uint8(uint256(assets[assetId].packedTermsState[151] >> 248))),\n\n            uint256(assets[assetId].packedTermsState[152]),\n            uint256(assets[assetId].packedTermsState[153]),\n            uint256(assets[assetId].packedTermsState[154]),\n            uint256(assets[assetId].packedTermsState[155]),\n            uint256(assets[assetId].packedTermsState[156]),\n\n            int256(assets[assetId].packedTermsState[157]),\n            int256(assets[assetId].packedTermsState[158]),\n            int256(assets[assetId].packedTermsState[159]),\n            int256(assets[assetId].packedTermsState[160]),\n            int256(assets[assetId].packedTermsState[161]),\n            int256(assets[assetId].packedTermsState[162]),\n            int256(assets[assetId].packedTermsState[163]),\n            int256(assets[assetId].packedTermsState[164])\n        );\n    }\n}\n"
    },
    "contracts/Core/TemplateRegistry/ITemplateRegistry.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./TemplateRegistryStorage.sol\";\n\n\nabstract contract ITemplateRegistry is TemplateRegistryStorage {\n\n    function isRegistered(bytes32 templateId)\n        external\n        view\n        virtual\n        returns (bool);\n\n    function getTemplateTerms(bytes32 templateId)\n        external\n        view\n        virtual\n        returns (TemplateTerms memory);\n\n    function getEventAtIndex(bytes32 templateId, uint256 index)\n        external\n        view\n        virtual\n        returns (bytes32);\n\n    function getScheduleLength(bytes32 templateId)\n        external\n        view\n        virtual\n        returns (uint256);\n\n    function registerTemplate(TemplateTerms memory terms, bytes32[] memory templateSchedule)\n        public\n        virtual;\n}"
    },
    "contracts/Core/TemplateRegistry/TemplateRegistryStorage.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../SharedTypes.sol\";\n\n\n/**\n * @title TemplateRegistryStorage\n * @notice Describes the storage of the TemplateRegistry.\n * Contains getter and setter methods for encoding, decoding data to optimize gas cost\n * Circumvents storing default values by relying on the characteristic of mappings returning zero for not set values.\n */\ncontract TemplateRegistryStorage is SharedTypes {\n\n    struct Template {\n        // boolean indicating that template exists\n        bool isSet;\n        // the schedule of the template\n        TemplateSchedule templateSchedule;\n        // tightly packed, encoded TemplateTerms\n        // bytes32(0) used as default value for each attribute\n        // storage id => bytes32 encoded value\n        mapping (uint256 => bytes32) packedTerms;\n    }\n\n    mapping (bytes32 => Template) templates;\n\n\n    function setTemplate(\n        bytes32 templateId,\n        TemplateTerms memory terms,\n        bytes32[] memory templateSchedule\n    )\n        internal\n    {\n        templates[templateId] = Template({\n            isSet: true,\n            templateSchedule: TemplateSchedule({ length: 0 })\n        });\n\n        encodeAndSetTerms(templateId, terms);\n        encodeAndSetSchedule(templateId, templateSchedule);\n    }\n\n    function encodeAndSetTerms(bytes32 templateId, TemplateTerms memory terms) internal {\n        bytes32 enums =\n            bytes32(uint256(uint8(terms.calendar))) << 240 |\n            bytes32(uint256(uint8(terms.contractRole))) << 232 |\n            bytes32(uint256(uint8(terms.dayCountConvention))) << 224 |\n            bytes32(uint256(uint8(terms.businessDayConvention))) << 216 |\n            bytes32(uint256(uint8(terms.endOfMonthConvention))) << 208 |\n            bytes32(uint256(uint8(terms.scalingEffect))) << 200 |\n            bytes32(uint256(uint8(terms.penaltyType))) << 192 |\n            bytes32(uint256(uint8(terms.feeBasis))) << 184 |\n            bytes32(uint256(uint8(terms.creditEventTypeCovered))) << 176;\n\n        if (enums != bytes32(0)) templates[templateId].packedTerms[1] = enums;\n\n        if (terms.currency != address(0)) templates[templateId].packedTerms[2] = bytes32(uint256(terms.currency) << 96);\n        if (terms.settlementCurrency != address(0)) templates[templateId].packedTerms[3] = bytes32(uint256(terms.settlementCurrency) << 96);\n\n        if (terms.marketObjectCodeRateReset != bytes32(0)) templates[templateId].packedTerms[4] = bytes32(terms.marketObjectCodeRateReset);\n\n        if (terms.statusDateOffset != uint256(0)) templates[templateId].packedTerms[5] = bytes32(terms.statusDateOffset);\n        if (terms.maturityDateOffset != uint256(0)) templates[templateId].packedTerms[6] = bytes32(terms.maturityDateOffset);\n\n        if (terms.notionalPrincipal != int256(0)) templates[templateId].packedTerms[7] = bytes32(terms.notionalPrincipal);\n        if (terms.nominalInterestRate != int256(0)) templates[templateId].packedTerms[8] = bytes32(terms.nominalInterestRate);\n        if (terms.feeAccrued != int256(0)) templates[templateId].packedTerms[9] = bytes32(terms.feeAccrued);\n        if (terms.accruedInterest != int256(0)) templates[templateId].packedTerms[10] = bytes32(terms.accruedInterest);\n        if (terms.rateMultiplier != int256(0)) templates[templateId].packedTerms[11] = bytes32(terms.rateMultiplier);\n        if (terms.rateSpread != int256(0)) templates[templateId].packedTerms[12] = bytes32(terms.rateSpread);\n        if (terms.feeRate != int256(0)) templates[templateId].packedTerms[13] = bytes32(terms.feeRate);\n        if (terms.nextResetRate != int256(0)) templates[templateId].packedTerms[14] = bytes32(terms.nextResetRate);\n        if (terms.penaltyRate != int256(0)) templates[templateId].packedTerms[15] = bytes32(terms.penaltyRate);\n        if (terms.premiumDiscountAtIED != int256(0)) templates[templateId].packedTerms[16] = bytes32(terms.premiumDiscountAtIED);\n        if (terms.priceAtPurchaseDate != int256(0)) templates[templateId].packedTerms[17] = bytes32(terms.priceAtPurchaseDate);\n        // solium-disable-next-line\n        if (terms.nextPrincipalRedemptionPayment != int256(0)) templates[templateId].packedTerms[18] = bytes32(terms.nextPrincipalRedemptionPayment);\n        // solium-disable-next-line\n        if (terms.coverageOfCreditEnhancement != int256(0)) templates[templateId].packedTerms[19] = bytes32(terms.coverageOfCreditEnhancement);\n        if (terms.lifeCap != int256(0)) templates[templateId].packedTerms[20] = bytes32(terms.lifeCap);\n        if (terms.lifeFloor != int256(0)) templates[templateId].packedTerms[21] = bytes32(terms.lifeFloor);\n        if (terms.periodCap != int256(0)) templates[templateId].packedTerms[22] = bytes32(terms.periodCap);\n        if (terms.periodFloor != int256(0)) templates[templateId].packedTerms[23] = bytes32(terms.periodFloor);\n\n        if (terms.gracePeriod.isSet) {\n            templates[templateId].packedTerms[24] =\n                bytes32(uint256(terms.gracePeriod.i)) << 24 |\n                bytes32(uint256(terms.gracePeriod.p)) << 16 |\n                bytes32(uint256(1)) << 8;\n        }\n        if (terms.delinquencyPeriod.isSet) {\n            templates[templateId].packedTerms[25] =\n                bytes32(uint256(terms.delinquencyPeriod.i)) << 24 |\n                bytes32(uint256(terms.delinquencyPeriod.p)) << 16 |\n                bytes32(uint256(1)) << 8;\n        }\n    }\n\n    function encodeAndSetSchedule(bytes32 templateId, bytes32[] memory templateSchedule)\n        internal\n    {\n        require(\n            templateSchedule.length != 0,\n            \"TemplateRegistry.encodeAndSetSchedule: EMPTY_SCHEDULE\"\n        );\n        require(\n            templateSchedule.length < MAX_EVENT_SCHEDULE_SIZE,\n            \"TemplateRegistry.encodeAndSetSchedule: MAX_EVENT_SCHEDULE_SIZE\"\n        );\n\n        for (uint256 i = 0; i < templateSchedule.length; i++) {\n            if (templateSchedule[i] == bytes32(0)) break;\n            templates[templateId].templateSchedule.events[i] = templateSchedule[i];\n            templates[templateId].templateSchedule.length = i + 1;\n        }\n    }\n\n    function decodeAndGetTerms(bytes32 templateId)\n        internal\n        view\n        returns (TemplateTerms memory)\n    {\n        return TemplateTerms(\n            Calendar(uint8(uint256(templates[templateId].packedTerms[1] >> 240))),\n            ContractRole(uint8(uint256(templates[templateId].packedTerms[1] >> 232))),\n            DayCountConvention(uint8(uint256(templates[templateId].packedTerms[1] >> 224))),\n            BusinessDayConvention(uint8(uint256(templates[templateId].packedTerms[1] >> 216))),\n            EndOfMonthConvention(uint8(uint256(templates[templateId].packedTerms[1] >> 208))),\n            ScalingEffect(uint8(uint256(templates[templateId].packedTerms[1] >> 200))),\n            PenaltyType(uint8(uint256(templates[templateId].packedTerms[1] >> 192))),\n            FeeBasis(uint8(uint256(templates[templateId].packedTerms[1] >> 184))),\n            ContractPerformance(uint8(uint256(templates[templateId].packedTerms[1] >> 176))),\n\n            address(uint160(uint256(templates[templateId].packedTerms[2]) >> 96)),\n            address(uint160(uint256(templates[templateId].packedTerms[3]) >> 96)),\n\n            templates[templateId].packedTerms[4],\n\n            uint256(templates[templateId].packedTerms[5]),\n            uint256(templates[templateId].packedTerms[6]),\n            int256(templates[templateId].packedTerms[7]),\n            int256(templates[templateId].packedTerms[8]),\n            int256(templates[templateId].packedTerms[9]),\n            int256(templates[templateId].packedTerms[10]),\n            int256(templates[templateId].packedTerms[11]),\n            int256(templates[templateId].packedTerms[12]),\n            int256(templates[templateId].packedTerms[13]),\n            int256(templates[templateId].packedTerms[14]),\n            int256(templates[templateId].packedTerms[15]),\n            int256(templates[templateId].packedTerms[16]),\n            int256(templates[templateId].packedTerms[17]),\n            int256(templates[templateId].packedTerms[18]),\n            int256(templates[templateId].packedTerms[19]),\n            int256(templates[templateId].packedTerms[20]),\n            int256(templates[templateId].packedTerms[21]),\n            int256(templates[templateId].packedTerms[22]),\n            int256(templates[templateId].packedTerms[23]),\n\n            IP(\n                uint256(templates[templateId].packedTerms[24] >> 24),\n                P(uint8(uint256(templates[templateId].packedTerms[24] >> 16))),\n                (templates[templateId].packedTerms[24] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            ),\n            IP(\n                uint256(templates[templateId].packedTerms[25] >> 24),\n                P(uint8(uint256(templates[templateId].packedTerms[25] >> 16))),\n                (templates[templateId].packedTerms[25] >> 8 & bytes32(uint256(1)) == bytes32(uint256(1))) ? true : false\n            )\n        );\n    }\n}\n"
    },
    "contracts/Core/MarketObjectRegistry/IMarketObjectRegistry.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./MarketObjectRegistryStorage.sol\";\n\n\nabstract contract IMarketObjectRegistry is MarketObjectRegistryStorage {\n\n    function setMarketObjectProvider(\n        bytes32 marketObjectId,\n        address provider\n    )\n        public\n        virtual;\n\n    function publishDataPointOfMarketObject(\n        bytes32 marketObjectId,\n        uint256 timestamp,\n        int256 dataPoint\n    )\n        public\n        virtual;\n\n    function getDataPointOfMarketObject(\n        bytes32 marketObjectId,\n        uint256 timestamp\n    )\n        public\n        view\n        virtual\n        returns (int256, bool);\n\n    function getMarketObjectLastUpdatedTimestamp(bytes32 marketObjectId)\n        public\n        view\n        virtual\n        returns (uint256);\n}\n"
    },
    "contracts/Core/MarketObjectRegistry/MarketObjectRegistryStorage.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../SharedTypes.sol\";\n\n\n/**\n * @title MarketObjectRegistryStorage\n * @notice Describes the storage of the MarketObjectRegistry\n */\ncontract MarketObjectRegistryStorage is SharedTypes {\n\n    struct DataPoint {\n        int256 dataPoint;\n        bool isSet;\n    }\n\n    // marketObjectId => timestamp => DataPoint\n    mapping(bytes32 => mapping(uint256 => DataPoint)) dataPoints;\n    // marketObjectId => lastUpdatedTimestamp\n    mapping(bytes32 => uint256) marketObjectLastUpdatedAt;\n    // marketObjectId => marketObjectProvider\n    mapping(bytes32 => address) marketObjectProviders;\n}"
    },
    "contracts/Core/AssetActor/IAssetActor.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../SharedTypes.sol\";\n\n\nabstract contract IAssetActor is SharedTypes {\n\n    function progress(bytes32 assetId)\n        external\n        virtual;\n\n    function progressWith(bytes32 assetId, bytes32 _event)\n        external\n        virtual;\n\n    function initialize(\n        bytes32 assetId,\n        AssetOwnership memory ownership,\n        bytes32 templateId,\n        CustomTerms memory customTerms,\n        address engine,\n        address root\n    )\n        public\n        virtual\n        returns (bool);\n}\n"
    },
    "contracts/Core/AssetRegistry/AccessControl.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./AssetRegistryStorage.sol\";\nimport \"./IAssetRegistry.sol\";\n\n\nabstract contract AccessControl is AssetRegistryStorage, IAssetRegistry {\n\n    event SetRootAccess(bytes32 indexed assetId, address indexed account);\n    event GrantedAccess(bytes32 indexed assetId, address indexed account, bytes4 methodSignature);\n    event RevokedAccess(bytes32 indexed assetId, address indexed account, bytes4 methodSignature);\n\n\n    // Method signature == bytes4(0) := Access to all methods defined in the Asset Registry contract\n    bytes4 constant ROOT_ACCESS = bytes4(0);\n\n\n    /**\n     * @notice Check whether an account is allowed to call a specific method on a specific asset.\n     * @param assetId id of the asset\n     * @param methodSignature function / method signature (4 byte keccak256 hash of the method selector)\n     * @param account address of the account for which to check access\n     * @return true if allowed access\n     */\n    function hasAccess (bytes32 assetId, bytes4 methodSignature, address account)\n        public\n        override\n        returns (bool)\n    {\n        return (\n            assets[assetId].access[methodSignature][account] || assets[assetId].access[ROOT_ACCESS][account]\n        );\n    }\n\n    /**\n     * @notice Check whether an account has root access for a specific asset.\n     * @param assetId id of the asset\n     * @param account address of the account for which to check root acccess\n     * @return  true if has root access\n     */\n    function hasRootAccess (bytes32 assetId, address account)\n        public\n        override\n        returns (bool)\n    {\n        return (assets[assetId].access[ROOT_ACCESS][account]);\n    }\n\n    /**\n     * @notice Grant access to an account to call a specific method on a specific asset.\n     * @dev Can only be called by an authorized account.\n     * @param assetId id of the asset\n     * @param methodSignature function / method signature (4 byte keccak256 hash of the method selector)\n     * @param account address of the account to grant access to\n     */\n    function grantAccess (bytes32 assetId, bytes4 methodSignature, address account)\n        public\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.revokeAccess: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].access[methodSignature][account] = true;\n\n        emit GrantedAccess(assetId, account, methodSignature);\n    }\n\n    /**\n     * @notice Revoke access for an account to call a specific method on a specific asset.\n     * @dev Can only be called by an authorized account.\n     * @param assetId id of the asset\n     * @param methodSignature function / method signature (4 byte keccak256 hash of the method selector)\n     * @param account address of the account to revoke access for\n     */\n    function revokeAccess (bytes32 assetId, bytes4 methodSignature, address account)\n        public\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.revokeAccess: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].access[methodSignature][account] = false;\n\n        emit RevokedAccess(assetId, account, methodSignature);\n    }\n\n    /**\n     * @notice Grant access to an account to call all methods on a specific asset\n     * (giving the account root access to an asset).\n     * @param assetId id of the asset\n     * @param account address of the account to set as the root\n     */\n    function setDefaultRoot (bytes32 assetId, address account) internal {\n        assets[assetId].access[ROOT_ACCESS][account] = true;\n\n        emit SetRootAccess(assetId, account);\n    }\n}\n"
    },
    "contracts/Core/AssetRegistry/AssetRegistry.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./AssetRegistryStorage.sol\";\nimport \"./IAssetRegistry.sol\";\nimport \"./Economics.sol\";\nimport \"./Ownership.sol\";\n\n\n/**\n * @title AssetRegistry\n * @notice Registry for ACTUS Protocol assets\n */\ncontract AssetRegistry is AssetRegistryStorage, IAssetRegistry, Economics, Ownership {\n\n    event RegisteredAsset(bytes32 assetId);\n\n\n    constructor(ITemplateRegistry _templateRegistry)\n        public\n        AssetRegistryStorage(_templateRegistry)\n    {}\n\n    /**\n     * @notice Returns if there is an asset registerd for a given assetId\n     * @param assetId id of the asset\n     * @return true if asset exist\n     */\n    function isRegistered(bytes32 assetId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return assets[assetId].isSet;\n    }\n\n    /**\n     * @notice Stores the addresses of the owners (owner of creator-side payment obligations,\n     * owner of creator-side payment claims), terms and the initial state of an asset\n     * and sets the address of the actor (address of account which is allowed to update the state).\n     * @dev The state of the asset can only be updates by a whitelisted actor.\n     * @param assetId id of the asset\n     * @param ownership ownership of the asset\n     * @param templateId id of the financial template to use\n     * @param terms asset specific terms (CustomTerms)\n     * @param state initial state of the asset\n     * @param engine ACTUS Engine of the asset\n     * @param actor account which is allowed to update the asset state\n     * @param admin account which as admin rights (optional)\n     */\n    function registerAsset(\n        bytes32 assetId,\n        AssetOwnership memory ownership,\n        bytes32 templateId,\n        CustomTerms memory terms,\n        State memory state,\n        address engine,\n        address actor,\n        address admin\n    )\n        public\n        override\n    {\n        // revert if an asset with the specified assetId already exists\n        require(\n            assets[assetId].isSet == false,\n            \"AssetRegistry.registerAsset: ENTRY_ALREADY_EXISTS\"\n        );\n\n        // store the asset\n        setAsset(\n            assetId,\n            ownership,\n            templateId,\n            terms,\n            state,\n            engine,\n            actor\n        );\n\n        // set external admin if specified\n        if (admin != address(0)) {\n            setDefaultRoot(assetId, admin);\n        }\n\n        emit RegisteredAsset(assetId);\n    }\n}\n"
    },
    "contracts/Core/AssetRegistry/Economics.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./AssetRegistryStorage.sol\";\nimport \"./AccessControl.sol\";\nimport \"./IAssetRegistry.sol\";\n\n\n/**\n * @title Economics\n */\nabstract contract Economics is AssetRegistryStorage, IAssetRegistry, AccessControl {\n\n    event IncrementedScheduleIndex(bytes32 indexed assetId, uint256 nextScheduleIndex);\n    event UpdatedCustomTerms(bytes32 indexed assetId);\n    event UpdatedState(bytes32 indexed assetId, uint256 statusDate);\n    event UpdatedFinalizedState(bytes32 indexed assetId, uint256 statusDate);\n    event UpdatedAnchorDate(bytes32 indexed assetId, uint256 prevAnchorDate, uint256 anchorDate);\n    event UpdatedEngine(bytes32 indexed assetId, address prevEngine, address newEngine);\n    event UpdatedActor(bytes32 indexed assetId, address prevActor, address newActor);\n\n\n    modifier isAuthorized(bytes32 assetId) {\n        require(\n            msg.sender == assets[assetId].actor || hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.isAuthorized: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Returns the terms of an asset.\n     * @param assetId id of the asset\n     * @return terms of the asset\n     */\n    function getTerms(bytes32 assetId)\n        external\n        view\n        override\n        returns (LifecycleTerms memory)\n    {\n        return decodeAndGetTerms(assetId);\n    }\n\n    /**\n     * @notice Returns the state of an asset.\n     * @param assetId id of the asset\n     * @return state of the asset\n     */\n    function getState(bytes32 assetId)\n        external\n        view\n        override\n        returns (State memory)\n    {\n        return decodeAndGetState(assetId);\n    }\n\n    /**\n     * @notice Returns the state of an asset.\n     * @param assetId id of the asset\n     * @return state of the asset\n     */\n    function getFinalizedState(bytes32 assetId)\n        external\n        view\n        override\n        returns (State memory)\n    {\n        return decodeAndGetFinalizedState(assetId);\n    }\n\n    /**\n     * @notice Returns the anchor date of an asset.\n     * @param assetId id of the asset\n     * @return Anchor date\n     */\n    function getAnchorDate(bytes32 assetId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return decodeAndGetAnchorDate(assetId);\n    }\n\n    /**\n     * @notice Returns the address of a the ACTUS engine corresponding to the ContractType of an asset.\n     * @param assetId id of the asset\n     * @return address of the engine of the asset\n     */\n    function getEngine(bytes32 assetId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assets[assetId].engine;\n    }\n\n    /**\n     * @notice Returns the address of the actor which is allowed to update the state of the asset.\n     * @param assetId id of the asset\n     * @return address of the asset actor\n     */\n    function getActor(bytes32 assetId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assets[assetId].actor;\n    }\n\n    /**\n     * @notice Returns the id of the template which this asset is based on.\n     * @param assetId id of the asset\n     * @return id of the template\n     */\n    function getTemplateId(bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return assets[assetId].templateId;\n    }\n\n    function getPendingEvent (bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return assets[assetId].pendingEvent;\n    }\n\n    function pushPendingEvent (bytes32 assetId, bytes32 pendingEvent)\n        external\n        override\n        isAuthorized (assetId)\n    {\n        assets[assetId].pendingEvent = pendingEvent;\n    }\n\n    function popPendingEvent (bytes32 assetId)\n        external\n        override\n        isAuthorized (assetId)\n        returns (bytes32)\n    {\n        bytes32 pendingEvent = assets[assetId].pendingEvent;\n        assets[assetId].pendingEvent = bytes32(0);\n\n        return pendingEvent;\n    }\n\n    /**\n     * @notice If the underlying of the asset changes in performance to a covered performance,\n     * it returns the exerciseDate event.\n     */\n    function getNextUnderlyingEvent (bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        LifecycleTerms memory terms = decodeAndGetTerms(assetId);\n        State memory state = decodeAndGetState(assetId);\n\n        // check for COVE\n        if (\n            terms.contractReference_1.object != bytes32(0)\n            && terms.contractReference_1.role == ContractReferenceRole.COVE\n        ) {\n            bytes32 underlyingAssetId = terms.contractReference_1.object;\n            State memory underlyingState = decodeAndGetState(underlyingAssetId);\n\n            require(\n                underlyingState.statusDate != uint256(0),\n                \"AssetActor.getNextObservedEvent: ENTRY_DOES_NOT_EXIST\"\n            );\n\n            // check if exerciseDate has been triggered\n            if (state.exerciseDate > 0) {\n                // insert SettlementDate event\n                return encodeEvent(\n                    EventType.STD,\n                    // solium-disable-next-line\n                    block.timestamp\n                );\n            // if not check if performance of underlying asset is covered by this asset (PF excluded)\n            } else if (\n                terms.creditEventTypeCovered != ContractPerformance.PF\n                && underlyingState.contractPerformance == terms.creditEventTypeCovered\n            ) {\n                // insert exerciseDate event\n                // derive scheduleTimeOffset from performance\n                if (underlyingState.contractPerformance == ContractPerformance.DL) {\n                    return encodeEvent(\n                        EventType.XD,\n                        underlyingState.nonPerformingDate\n                    );\n                } else if (underlyingState.contractPerformance == ContractPerformance.DQ) {\n                    LifecycleTerms memory underlyingTerms = decodeAndGetTerms(underlyingAssetId);\n                    return encodeEvent(\n                        EventType.XD,\n                        getTimestampPlusPeriod(underlyingTerms.gracePeriod, underlyingState.nonPerformingDate)\n                    );\n                } else if (underlyingState.contractPerformance == ContractPerformance.DF) {\n                    LifecycleTerms memory underlyingTerms = decodeAndGetTerms(underlyingAssetId);\n                    return encodeEvent(\n                        EventType.XD,\n                        getTimestampPlusPeriod(underlyingTerms.delinquencyPeriod, underlyingState.nonPerformingDate)\n                    );\n                }\n            }\n        }\n\n        return encodeEvent(EventType(0), 0);\n    }\n\n\n    /**\n     * @notice Returns the index of the next event to be processed for a schedule of an asset.\n     * @param assetId id of the asset\n     * @return Index\n     */\n    function getNextScheduleIndex(bytes32 assetId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return assets[assetId].nextScheduleIndex;\n    }\n\n    /**\n     * @notice Returns the next event to process.\n     * @param assetId id of the asset\n     * @return event\n     */\n    function getNextScheduledEvent (bytes32 assetId)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        if (templateRegistry.getScheduleLength(assets[assetId].templateId) == 0) {\n            return encodeEvent(EventType(0), 0);\n        }\n        \n        bytes32 _event = templateRegistry.getEventAtIndex(\n            assets[assetId].templateId,\n            assets[assetId].nextScheduleIndex\n        );\n        (EventType nextEventType, uint256 nextScheduleTimeOffset) = decodeEvent(_event);\n\n        return encodeEvent(\n            nextEventType,\n            applyAnchorDateToOffset(decodeAndGetAnchorDate(assetId), nextScheduleTimeOffset)\n        );\n    }\n\n    /**\n     * @notice Increments the index of a schedule of an asset.\n     * (if max index is reached the index will be left unchanged)\n     * @dev Can only be updated by the assets actor or by an authorized account.\n     * @param assetId id of the asset\n     */\n    function popNextScheduledEvent(bytes32 assetId)\n        external\n        override\n        isAuthorized (assetId)\n        returns (bytes32)\n    {\n        if (assets[assetId].nextScheduleIndex == templateRegistry.getScheduleLength(assets[assetId].templateId)) {\n            return encodeEvent(EventType(0), 0);\n        }\n\n        bytes32 _event = templateRegistry.getEventAtIndex(\n            assets[assetId].templateId,\n            assets[assetId].nextScheduleIndex\n        );\n        (EventType nextEventType, uint256 nextScheduleTimeOffset) = decodeEvent(_event);\n\n        assets[assetId].nextScheduleIndex += 1;\n        emit IncrementedScheduleIndex(assetId, assets[assetId].nextScheduleIndex);\n\n        return encodeEvent(\n            nextEventType,\n            applyAnchorDateToOffset(decodeAndGetAnchorDate(assetId), nextScheduleTimeOffset)\n        );\n    }\n\n    /**\n     * @notice Set the custom terms of the asset\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param terms new CustomTerms\n     */\n    function setCustomTerms(bytes32 assetId, CustomTerms memory terms)\n        public\n        override\n        isAuthorized (assetId)\n    {\n        encodeAndSetTerms(assetId, terms);\n\n        emit UpdatedCustomTerms(assetId);\n    }\n\n    /**\n     * @notice Sets next state of an asset.\n     * @dev Can only be updated by the assets actor or by an authorized account.\n     * @param assetId id of the asset\n     * @param state next state of the asset\n     */\n    function setState(bytes32 assetId, State memory state)\n        public\n        override\n        isAuthorized (assetId)\n    {\n        encodeAndSetState(assetId, state);\n\n        emit UpdatedState(assetId, state.statusDate);\n    }\n\n    /**\n     * @notice Sets next finalized state of an asset.\n     * @dev Can only be updated by the assets actor or by an authorized account.\n     * @param assetId id of the asset\n     * @param state next state of the asset\n     */\n    function setFinalizedState(bytes32 assetId, State memory state)\n        public\n        override\n        isAuthorized (assetId)\n    {\n        encodeAndSetFinalizedState(assetId, state);\n\n        emit UpdatedFinalizedState(assetId, state.statusDate);\n    }\n\n    /**\n     * @notice Set the anchor date which should used going forward to derive dates from the template\n     * (used e.g. for pausing the asset).\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param anchorDate new anchor date of the asset\n     */\n    function setAnchorDate(bytes32 assetId, uint256 anchorDate)\n        public\n        override\n        isAuthorized (assetId)\n    {\n        uint256 prevAnchorDate = decodeAndGetAnchorDate(assetId);\n\n        encodeAndSetAnchorDate(assetId, anchorDate);\n\n        emit UpdatedAnchorDate(assetId, prevAnchorDate, anchorDate);\n    }\n\n    /**\n     * @notice Set the engine address which should be used for the asset going forward.\n     * @dev Can only be set by authorized account.\n     * @param assetId id of the asset\n     * @param engine new engine address\n     */\n    function setEngine(bytes32 assetId, address engine)\n        public\n        override\n        isAuthorized (assetId)\n    {\n        address prevEngine = assets[assetId].engine;\n\n        assets[assetId].engine = engine;\n\n        emit UpdatedEngine(assetId, prevEngine, engine);\n    }\n\n    /**\n     * @notice Set the address of the Actor contract which should be going forward.\n     * @param assetId id of the asset\n     * @param actor address of the Actor contract\n     */\n    function setActor(bytes32 assetId, address actor)\n        public\n        override\n        isAuthorized (assetId)\n    {\n        address prevActor = assets[assetId].actor;\n\n        assets[assetId].actor = actor;\n\n        emit UpdatedActor(assetId, prevActor, actor);\n    }\n}\n"
    },
    "contracts/Core/AssetRegistry/Ownership.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./AssetRegistryStorage.sol\";\nimport \"./AccessControl.sol\";\nimport \"./IAssetRegistry.sol\";\n\n\n/**\n * @title Ownership\n */\nabstract contract Ownership is AssetRegistryStorage, IAssetRegistry, AccessControl {\n\n    event UpdatedObligor (bytes32 assetId, address prevObligor, address newObligor);\n    event UpdatedBeneficiary(bytes32 assetId, address prevBeneficiary, address newBeneficiary);\n    event UpdatedCashflowBeneficiary(bytes32 assetId, int8 cashflowId, address prevBeneficiary, address newBeneficiary);\n\n\n    /**\n     * @notice Update the address of the default beneficiary of cashflows going to the creator.\n     * @dev Can only be updated by the current creator beneficiary or by an authorized account.\n     * @param assetId id of the asset\n     * @param newCreatorBeneficiary address of the new beneficiary\n     */\n    function setCreatorBeneficiary(\n        bytes32 assetId,\n        address newCreatorBeneficiary\n    )\n        external\n        override\n    {\n        address prevCreatorBeneficiary = assets[assetId].ownership.creatorBeneficiary;\n\n        require(\n            prevCreatorBeneficiary != address(0),\n            \"AssetRegistry.setCreatorBeneficiary: ENTRY_DOES_NOT_EXIST\"\n        );\n        require(\n            msg.sender == prevCreatorBeneficiary || hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCreatorBeneficiary: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].ownership.creatorBeneficiary = newCreatorBeneficiary;\n\n        emit UpdatedBeneficiary(assetId, prevCreatorBeneficiary, newCreatorBeneficiary);\n    }\n\n    /**\n     * @notice Updates the address of the default beneficiary of cashflows going to the counterparty.\n     * @dev Can only be updated by the current counterparty beneficiary or by an authorized account.\n     * @param assetId id of the asset\n     * @param newCounterpartyBeneficiary address of the new beneficiary\n     */\n    function setCounterpartyBeneficiary(\n        bytes32 assetId,\n        address newCounterpartyBeneficiary\n    )\n        external\n        override\n    {\n        address prevCounterpartyBeneficiary = assets[assetId].ownership.counterpartyBeneficiary;\n\n        require(\n            prevCounterpartyBeneficiary != address(0),\n            \"AssetRegistry.setCounterpartyBeneficiary: ENTRY_DOES_NOT_EXIST\"\n        );\n        require(\n            msg.sender == prevCounterpartyBeneficiary || hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCounterpartyBeneficiary: UNAUTHORIZED_SENDER\"\n        );\n\n        assets[assetId].ownership.counterpartyBeneficiary = newCounterpartyBeneficiary;\n\n        emit UpdatedBeneficiary(assetId, prevCounterpartyBeneficiary, newCounterpartyBeneficiary);\n    }\n\n    /**\n     * @notice Registers the address of the owner of specific claims of the asset.\n     * @dev Can only be updated by the current beneficiary or by an authorized account.\n     * @param assetId id of the asset\n     * @param cashflowId id of the specific claims for which to register the owner\n     * @param beneficiary the address of the owner\n     */\n    function setBeneficiaryForCashflowId(\n        bytes32 assetId,\n        int8 cashflowId,\n        address beneficiary\n    )\n        external\n        override\n    {\n        require(\n            cashflowId != 0,\n            \"AssetRegistry.setBeneficiaryForCashflowId: INVALID_CASHFLOWID\"\n        );\n\n        address prevBeneficiary = assets[assetId].cashflowBeneficiaries[cashflowId];\n\n        if (prevBeneficiary == address(0)) {\n            if (cashflowId > 0) {\n                require(\n                    msg.sender == assets[assetId].ownership.creatorBeneficiary\n                    || hasAccess(assetId, msg.sig, msg.sender),\n                    \"AssetRegistry.setBeneficiaryForCashflowId: UNAUTHORIZED_SENDER\"\n                );\n            } else {\n                require(\n                    msg.sender == assets[assetId].ownership.counterpartyBeneficiary\n                    || hasAccess(assetId, msg.sig, msg.sender),\n                    \"AssetRegistry.setBeneficiaryForCashflowId: UNAUTHORIZED_SENDER\"\n                );\n            }\n        } else {\n            require(\n                msg.sender == prevBeneficiary || hasAccess(assetId, msg.sig, msg.sender),\n                \"AssetRegistry.setBeneficiaryForCashflowId: UNAUTHORIZED_SENDER\"\n            );\n        }\n\n        assets[assetId].cashflowBeneficiaries[cashflowId] = beneficiary;\n\n        emit UpdatedCashflowBeneficiary(\n            assetId,\n            cashflowId,\n            prevBeneficiary,\n            beneficiary\n        );\n    }\n\n    /**\n     * @notice Update the address of the obligor which has to fulfill obligations\n     * for the creator of the asset.\n     * @dev Can only be updated by an authorized account.\n     * @param assetId id of the asset\n     * @param newCreatorObligor address of the new creator obligor\n     */\n    function setCreatorObligor (bytes32 assetId, address newCreatorObligor)\n        external\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCreatorObligor: UNAUTHORIZED_SENDER\"\n        );\n\n        address prevCreatorObligor = assets[assetId].ownership.creatorObligor;\n\n        assets[assetId].ownership.creatorObligor = newCreatorObligor;\n\n        emit UpdatedObligor(assetId, prevCreatorObligor, newCreatorObligor);\n    }\n\n    /**\n     * @notice Update the address of the counterparty which has to fulfill obligations\n     * for the counterparty of the asset.\n     * @dev Can only be updated by an authorized account.\n     * @param assetId id of the asset\n     * @param newCounterpartyObligor address of the new counterparty obligor\n     */\n    function setCounterpartyObligor (bytes32 assetId, address newCounterpartyObligor)\n        external\n        override\n    {\n        require(\n            hasAccess(assetId, msg.sig, msg.sender),\n            \"AssetRegistry.setCounterpartyObligor: UNAUTHORIZED_SENDER\"\n        );\n\n        address prevCounterpartyObligor = assets[assetId].ownership.counterpartyObligor;\n\n        assets[assetId].ownership.counterpartyObligor = newCounterpartyObligor;\n\n        emit UpdatedObligor(assetId, prevCounterpartyObligor, newCounterpartyObligor);\n    }\n\n    /**\n     * @notice Retrieves the registered addresses of owners (creator, counterparty) of an asset.\n     * @param assetId id of the asset\n     * @return addresses of all owners of the asset\n     */\n    function getOwnership(bytes32 assetId)\n        external\n        view\n        override\n        returns (AssetOwnership memory)\n    {\n        return assets[assetId].ownership;\n    }\n\n    /**\n     * @notice Retrieves the registered address of the owner of specific future claims from an asset.\n     * @param assetId id of the asset\n     * @param cashflowId the identifier of the specific claims owned by the registerd address\n     * @return address of the beneficiary corresponding to the given cashflowId\n     */\n    function getCashflowBeneficiary(bytes32 assetId, int8 cashflowId)\n        external\n        view\n        override\n        returns (address)\n    {\n        return assets[assetId].cashflowBeneficiaries[cashflowId];\n    }\n}\n"
    },
    "contracts/Core/MarketObjectRegistry/MarketObjectRegistry.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\n\nimport \"./IMarketObjectRegistry.sol\";\nimport \"./MarketObjectRegistryStorage.sol\";\n\n\n/**\n * @title MarketObjectRegistry\n * @notice Registry for data corresponding to a market object which is provided\n * by an registered MarketObjectProvider\n */\ncontract MarketObjectRegistry is MarketObjectRegistryStorage, IMarketObjectRegistry, Ownable {\n\n    event UpdatedMarketObjectProvider(bytes32 indexed marketObjectId, address provider);\n\n    event PublishedDataPoint(bytes32 indexed marketObjectId, int256 dataPoint);\n\n\n    /**\n     * @notice Registers / updates a market object provider.\n     * @dev Can only be called by the owner of the MarketObjectRegistry.\n     * @param marketObjectId id of the market object\n     * @param provider address of the provider\n     */\n    function setMarketObjectProvider(\n        bytes32 marketObjectId,\n        address provider\n    )\n        public\n        override\n        onlyOwner\n    {\n        marketObjectProviders[marketObjectId] = provider;\n\n        emit UpdatedMarketObjectProvider(marketObjectId, provider);\n    }\n\n    /**\n     * @notice Stores a new data point of a market object for a given timestamp.\n     * @dev Can only be called by a whitelisted market object provider.\n     * @param marketObjectId id of the market object (see ACTUS spec.)\n     * @param timestamp timestamp of the data point\n     * @param dataPoint the data point for the market object\n     */\n    function publishDataPointOfMarketObject(\n        bytes32 marketObjectId,\n        uint256 timestamp,\n        int256 dataPoint\n    )\n        public\n        override\n    {\n        require(\n            msg.sender == marketObjectProviders[marketObjectId],\n            \"MarketObjectRegistry.publishMarketObject: UNAUTHORIZED_SENDER\"\n        );\n\n        dataPoints[marketObjectId][timestamp] = DataPoint(dataPoint, true);\n        marketObjectLastUpdatedAt[marketObjectId] = timestamp;\n\n        emit PublishedDataPoint(marketObjectId, dataPoint);\n    }\n\n    /**\n     * @notice Returns a data point of a market object for a given timestamp.\n     * @param marketObjectId id of the market object\n     * @param timestamp timestamp of the data point\n     * @return data point, bool indicating whether data point exists\n     */\n    function getDataPointOfMarketObject(\n        bytes32 marketObjectId,\n        uint256 timestamp\n    )\n        public\n        view\n        override\n        returns (int256, bool)\n    {\n        return (\n            dataPoints[marketObjectId][timestamp].dataPoint,\n            dataPoints[marketObjectId][timestamp].isSet\n        );\n    }\n\n    /**\n     * @notice Returns the timestamp on which the last data point for a market object\n     * was submitted.\n     * @param marketObjectId id of the market object\n     * @return last updated timestamp\n     */\n    function getMarketObjectLastUpdatedTimestamp(bytes32 marketObjectId)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return marketObjectLastUpdatedAt[marketObjectId];\n    }\n}\n"
    },
    "contracts/Core/TemplateRegistry/TemplateRegistry.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./ITemplateRegistry.sol\";\nimport \"./TemplateRegistryStorage.sol\";\n\n\n/**\n * @title TemplateRegistry\n * @notice Registry for ACTUS compatible templates.\n * A Template is made up of a set of TemplateTerms and TemplateSchedules.\n */\ncontract TemplateRegistry is TemplateRegistryStorage, ITemplateRegistry {\n\n    event RegisteredTemplate(bytes32 indexed templateId);\n\n\n    /**\n     * @notice Returns true if there is a template registered for a given templateId\n     * @param templateId id of the template\n     * @return true if template exists\n     */\n    function isRegistered(bytes32 templateId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return templates[templateId].isSet;\n    }\n\n    /**\n     * @notice Returns the terms of a template.\n     * @param templateId id of the template\n     * @return TemplateTerms\n     */\n    function getTemplateTerms(bytes32 templateId)\n        external\n        view\n        override\n        returns (TemplateTerms memory)\n    {\n        return (decodeAndGetTerms(templateId));\n    }\n\n    /**\n     * @notice Returns an event for a given position (index) in a schedule of a given template.\n     * @param templateId id of the template\n     * @param index index of the event to return\n     * @return Event\n     */\n    function getEventAtIndex(bytes32 templateId, uint256 index)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return templates[templateId].templateSchedule.events[index];\n    }\n\n    /**\n     * @notice Returns the length of a schedule of a given template.\n     * @param templateId id of the template\n     * @return Length of the schedule\n     */\n    function getScheduleLength(bytes32 templateId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return templates[templateId].templateSchedule.length;\n    }\n\n    /**\n     * @notice Convenience method for retrieving the entire schedule\n     * Not recommended to execute method on-chain (if schedule is too long the tx may run out of gas)\n     * @param templateId id of the template\n     * @return the schedule\n     */\n    function getSchedule(bytes32 templateId)\n        external\n        view\n        returns (bytes32[] memory)\n    {\n        uint256 scheduleLength = templates[templateId].templateSchedule.length;\n        bytes32[] memory schedule = new bytes32[](scheduleLength);\n\n        for (uint256 i = 0; i < scheduleLength; i++) {\n            schedule[i] = templates[templateId].templateSchedule.events[i];\n        }\n\n        return schedule;\n    }\n\n    /**\n     * @notice Stores a new template for given set of TemplateTerms and TemplateSchedules.\n     * The templateId is derived from the hash of the TemplateTerms and the TemplateSchedules\n     * to circumvent duplicate TemplateTerms on-chain.\n     * @param terms set of TemplateTerms\n     * @param templateSchedule templateSchedule which encodes offsets for ScheduleTime relative to an AnchorDate + EventType\n     */\n    function registerTemplate(TemplateTerms memory terms, bytes32[] memory templateSchedule)\n        public\n        override\n    {\n        // derive the templateId from the hash of the provided TemplateTerms and TemplateSchedule\n        bytes32 templateId = keccak256(\n            abi.encode(\n                keccak256(abi.encode(terms)),\n                keccak256(abi.encode(templateSchedule))\n            )\n        );\n\n        // revert if a template for the derived template already exists\n        require(\n            templates[templateId].isSet == false,\n            \"TemplateRegistry.registerTemplate: ENTRY_ALREADY_EXISTS\"\n        );\n\n        // store the template\n        setTemplate(templateId, terms, templateSchedule);\n\n        emit RegisteredTemplate(templateId);\n    }\n}"
    },
    "contracts/external/Dependencies.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"@atpar/actus-solidity/contracts/Engines/ANNEngine.sol\";\nimport \"@atpar/actus-solidity/contracts/Engines/PAMEngine.sol\";\nimport \"@atpar/actus-solidity/contracts/Engines/CEGEngine.sol\";\nimport \"@atpar/actus-solidity/contracts/Engines/CECEngine.sol\";\n\n\ncontract Dependencies {}\n"
    },
    "@atpar/actus-solidity/contracts/Engines/ANNEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./IEngine.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title ANNEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a ANN contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract ANNEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * todo implement annuity calculator\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.notionalScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.interestScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.accruedInterest = roleSign(terms.contractRole) * terms.accruedInterest;\n        state.feeAccrued = terms.feeAccrued;\n        // annuity calculator to be implemented\n        state.nextPrincipalRedemptionPayment = roleSign(terms.contractRole) * terms.nextPrincipalRedemptionPayment;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * todo rate reset, scaling, interest calculation base\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // initial exchange\n        if (isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\n            _eventSchedule[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\n            index++;\n        }\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                _eventSchedule[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // principal redemption at maturity\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true)  {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        if (eventType == EventType.IP) {\n            uint256 index = 0;\n\n            // interest payment related (covers pre-repayment period only,\n            // starting with PRANX interest is paid following the PR schedule)\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n            ) {\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.maturityDate,\n                    terms.cycleOfInterestPayment,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (interestPaymentSchedule[i] <= terms.capitalizationEndDate) continue;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IP, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.IPCI) {\n            uint256 index = 0;\n\n            // IPCI\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n                && terms.capitalizationEndDate != 0\n                && terms.capitalizationEndDate < terms.cycleAnchorDateOfPrincipalRedemption\n            ) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.capitalizationEndDate,\n                    cycleOfInterestCapitalization,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IPCI, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.FP) {\n            uint256 index = 0;\n\n            // fees\n            if (terms.cycleOfFee.isSet == true && terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.PR) {\n            uint256 index = 0;\n\n            // principal redemption\n            uint256[MAX_CYCLE_SIZE] memory principalRedemptionSchedule = computeDatesFromCycleSegment(\n                terms.cycleAnchorDateOfPrincipalRedemption,\n                terms.maturityDate,\n                terms.cycleOfPrincipalRedemption,\n                false,\n                segmentStart,\n                segmentEnd\n            );\n            for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                if (principalRedemptionSchedule[i] == 0) break;\n                if (isInSegment(principalRedemptionSchedule[i], segmentStart, segmentEnd) == false) continue;\n                _eventSchedule[index] = encodeEvent(EventType.PR, principalRedemptionSchedule[i]);\n                index++;\n            }\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n        /*\n         * Note:\n         * not supported: IPCB events, PRD events\n         */\n        if (eventType == EventType.AD) return STF_PAM_AD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_PAM_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return STF_ANN_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IPCI) return STF_ANN_IPCI(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return STF_ANN_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return STF_PAM_PP(terms, state, scheduleTime, externalData);\n        //if (eventType == EventType.PRD) return STF_PAM_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PR) return STF_ANN_PR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_ANN_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PY) return STF_PAM_PY(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RRF) return STF_PAM_RRF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RR) return STF_ANN_RR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SC) return STF_ANN_SC(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_PAM_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"ANNEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * todo IPCB events and Icb state variable, Icb state variable updates in IP-paying events\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note: all ANN payoff functions that rely on NAM/LAM have been replaced by PAM\n         * actus-solidity currently doesn't support interestCalculationBase, thus we can use PAM\n         *\n         * There is a reference to a POF_ANN_PR function which was added because PAM doesn't have PR Events in ACTUS 1.0\n         * and NAM, which ANN refers to in the specification, is not yet supported\n         *\n         * not supported: IPCB events, PRD events\n         */\n        if (eventType == EventType.AD) return 0; // Analysis Event\n        if (eventType == EventType.IPCI) return 0; // Interest Capitalization Event\n        if (eventType == EventType.RRF) return 0; // Rate Reset Fixed\n        if (eventType == EventType.RR) return 0; // Rate Reset Variable\n        if (eventType == EventType.SC) return 0; // Scaling Index Revision\n        if (eventType == EventType.CE) return 0; // Credit Event\n        if (eventType == EventType.FP) return POF_PAM_FP(terms, state, scheduleTime, externalData); // Fee Payment\n        if (eventType == EventType.IED) return POF_PAM_IED(terms, state, scheduleTime, externalData); // Intital Exchange\n        if (eventType == EventType.IP) return POF_PAM_IP(terms, state, scheduleTime, externalData); // Interest Payment\n        if (eventType == EventType.PP) return POF_PAM_PP(terms, state, scheduleTime, externalData); // Principal Prepayment\n        //if (eventType == EventType.PRD) return POF_PAM_PRD(terms, state, scheduleTime, externalData); // Purchase\n        if (eventType == EventType.PR) return POF_ANN_PR(terms, state, scheduleTime, externalData); // Principal Redemption\n        if (eventType == EventType.MD) return POF_PAM_MD(terms, state, scheduleTime, externalData); // Maturity\n        if (eventType == EventType.PY) return POF_PAM_PY(terms, state, scheduleTime, externalData); // Penalty Payment\n        if (eventType == EventType.TD) return POF_PAM_TD(terms, state, scheduleTime, externalData); // Termination\n\n        revert(\"ANNEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}"
    },
    "@atpar/actus-solidity/contracts/Core/Core.sol": {
      "content": "pragma solidity ^0.6.4;\r\npragma experimental ABIEncoderV2;\r\n\r\nimport \"./ACTUSTypes.sol\";\r\nimport \"./Utils.sol\";\r\nimport \"./Schedule.sol\";\r\n\r\nimport \"./Conventions/BusinessDayConvention.sol\";\r\nimport \"./Conventions/ContractDefaultConvention.sol\";\r\nimport \"./Conventions/ContractRoleConvention.sol\";\r\nimport \"./Conventions/DayCountConvention.sol\";\r\nimport \"./Conventions/EndOfMonthConvention.sol\";\r\n\r\n\r\n/**\r\n * @title Core\r\n * @notice Contains all type definitions, conventions as specified by the ACTUS Standard\r\n * and utility methods for generating event schedules\r\n */\r\ncontract Core is\r\n    ACTUSTypes,\r\n    BusinessDayConvention,\r\n    ContractDefaultConvention,\r\n    ContractRoleConvention,\r\n    DayCountConvention,\r\n    EndOfMonthConvention,\r\n    Utils,\r\n    Schedule\r\n{}\r\n"
    },
    "@atpar/actus-solidity/contracts/Core/Schedule.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"./ACTUSTypes.sol\";\nimport \"./Utils.sol\";\n\n\n/**\n * @title Schedule\n * @notice Methods related to generating event schedules.\n */\ncontract Schedule is ACTUSTypes, Utils {\n\n    /**\n     * @notice Applies the cycle n - times (n := cycleIndex) to a given date\n     */\n    function getNextCycleDate(IPS memory cycle, uint256 cycleStart, uint256 cycleIndex)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 newTimestamp;\n\n        if (cycle.p == P.D) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(cycleStart, cycle.i * cycleIndex);\n        } else if (cycle.p == P.W) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(cycleStart, cycle.i * 7 * cycleIndex);\n        } else if (cycle.p == P.M) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(cycleStart, cycle.i * cycleIndex);\n        } else if (cycle.p == P.Q) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(cycleStart, cycle.i * 3 * cycleIndex);\n        } else if (cycle.p == P.H) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(cycleStart, cycle.i * 6 * cycleIndex);\n        } else if (cycle.p == P.Y) {\n            newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(cycleStart, cycle.i * cycleIndex);\n        } else {\n            revert(\"Schedule.getNextCycleDate: ATTRIBUTE_NOT_FOUND\");\n        }\n\n        return newTimestamp;\n    }\n\n    /**\n     * This function computes an array of UNIX timestamps that\n     * represent dates in a cycle falling within a given segment.\n     * @dev There are some notable edge cases: If the cycle is \"not set\" we return the start end end dates\n     * of the cycle if they lie within the segment. Otherwise and empty array is returned.\n     * @param cycleStart the start time of the cycle\n     * @param cycleEnd the end time of the cycle\n     * @param cycle struct that describe sthe cycle\n     * @param addEndTime specifies if the timestamp of the end of the cycle should be added to the result if it falls in the segment\n     * @param segmentStart start time of the segment\n     * @param segmentEnd end time of the segment\n     * @return an array of timestamps from the given cycle that fall within the specified segement\n     */\n    function computeDatesFromCycleSegment(\n        uint256 cycleStart,\n        uint256 cycleEnd,\n        IPS memory cycle,\n        bool addEndTime,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        internal\n        pure\n        returns (uint256[MAX_CYCLE_SIZE] memory)\n    {\n        uint256[MAX_CYCLE_SIZE] memory dates;\n        uint256 index = 0;\n\n        // if the cycle is not set we return only the cycle start end end dates under these conditions:\n        // we return the cycle start, if it's in the segment\n        // in case of addEntTime = true, the cycle end is also returned if in the segment\n        if (cycle.isSet == false) {\n            if (isInSegment(cycleStart, segmentStart, segmentEnd)) {\n                dates[index] = cycleStart;\n                index++;\n            }\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\n                if (addEndTime == true) dates[index] = cycleEnd;\n            }\n            return dates;\n        }\n\n        uint256 date = cycleStart;\n        uint256 cycleIndex = 0;\n\n        // walk through the cycle and create the cycle dates to be returned\n        while (date < cycleEnd) {\n            // if date is in segment and MAX_CYCLE_SIZE is not reached add it to the output array\n            if (isInSegment(date, segmentStart, segmentEnd)) {\n                require(index < (MAX_CYCLE_SIZE - 2), \"Schedule.computeDatesFromCycle: MAX_CYCLE_SIZE\");\n                dates[index] = date;\n                index++;\n            }\n\n            cycleIndex++;\n\n\n            date = getNextCycleDate(cycle, cycleStart, cycleIndex);\n\n        }\n\n        // add additional time at the end if addEndTime\n        if (addEndTime == true) {\n            if (isInSegment(cycleEnd, segmentStart, segmentEnd)) {\n                dates[index] = cycleEnd;\n            }\n        }\n\n        // handle a special case where S is set to LONG (e.g. for trimming a cycle to the maturity date)\n        if (index > 0 && isInSegment(dates[index - 1], segmentStart, segmentEnd)) {\n            if (cycle.s == S.LONG && index > 1 && cycleEnd != date) {\n                dates[index - 1] = dates[index];\n                delete dates[index];\n            }\n        }\n\n        return dates;\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Core/Conventions/ContractDefaultConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title ContractDefaultConvention\n */\ncontract ContractDefaultConvention is ACTUSTypes {\n\n    /**\n     * @notice Returns the performance indicator for a given performance\n     * (used a mutliplier in POFs)\n     */\n    function performanceIndicator(ContractPerformance contractPerformance)\n        internal\n        pure\n        returns (int8)\n    {\n        if (contractPerformance == ContractPerformance.DF) return 0;\n        return 1;\n    }\n}"
    },
    "@atpar/actus-solidity/contracts/Core/Conventions/ContractRoleConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title ContractRoleConvention\n */\ncontract ContractRoleConvention is ACTUSTypes {\n\n    /**\n     * Returns the role sign for a given Contract Role.\n     */\n    function roleSign(ContractRole contractRole)\n        internal\n        pure\n        returns (int8)\n    {\n        if (contractRole == ContractRole.RPA) return 1;\n        if (contractRole == ContractRole.RPL) return -1;\n\n        if (contractRole == ContractRole.BUY) return 1;\n        if (contractRole == ContractRole.SEL) return -1;\n\n        if (contractRole == ContractRole.RFL) return 1;\n        if (contractRole == ContractRole.PFL) return -1;\n\n        revert(\"ContractRoleConvention.roleSign: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Core/Conventions/DayCountConvention.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"openzeppelin-solidity/contracts/drafts/SignedSafeMath.sol\";\nimport \"../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\nimport \"../SignedMath.sol\";\n\n\n/**\n * @title DayCountConvention\n * @notice Implements various ISDA day count conventions as specified by ACTUS\n */\ncontract DayCountConvention is ACTUSTypes {\n\n    using SafeMath for uint;\n    using SignedSafeMath for int;\n    using SignedMath for int;\n\n    /**\n     * Returns the fraction of the year between two timestamps.\n     */\n    function yearFraction(\n        uint256 startTimestamp,\n        uint256 endTimestamp,\n        DayCountConvention ipdc,\n        uint256 maturityDate\n    )\n        internal\n        pure\n        returns (int256)\n    {\n        require(endTimestamp >= startTimestamp, \"Core.yearFraction: START_NOT_BEFORE_END\");\n        if (ipdc == DayCountConvention.AA) {\n            return actualActual(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention.A360) {\n            return actualThreeSixty(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention.A365) {\n            return actualThreeSixtyFive(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention._30E360) {\n            return thirtyEThreeSixty(startTimestamp, endTimestamp);\n        } else if (ipdc == DayCountConvention._30E360ISDA) {\n            return thirtyEThreeSixtyISDA(startTimestamp, endTimestamp, maturityDate);\n        } else if (ipdc == DayCountConvention._28E336) {\n            // not implemented yet\n            revert(\"DayCountConvention.yearFraction: ATTRIBUTE_NOT_SUPPORTED.\");\n        } else {\n            revert(\"DayCountConvention.yearFraction: ATTRIBUTE_NOT_FOUND.\");\n        }\n    }\n\n    /**\n     * ISDA A/A day count convention\n     */\n    function actualActual(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Year = BokkyPooBahsDateTimeLibrary.getYear(startTime);\n        uint256 d2Year = BokkyPooBahsDateTimeLibrary.getYear(endTime);\n\n        int256 firstBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(startTime)) ? 366 : 365;\n\n        if (d1Year == d2Year) {\n            return int256(BokkyPooBahsDateTimeLibrary.diffDays(startTime, endTime)).floatDiv(firstBasis);\n        }\n\n        int256 secondBasis = (BokkyPooBahsDateTimeLibrary.isLeapYear(endTime)) ? 366 : 365;\n\n        int256 firstFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\n            startTime,\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d1Year.add(1), 1, 1)\n        )).floatDiv(firstBasis);\n        int256 secondFraction = int256(BokkyPooBahsDateTimeLibrary.diffDays(\n            BokkyPooBahsDateTimeLibrary.timestampFromDate(d2Year, 1, 1),\n            endTime\n        )).floatDiv(secondBasis);\n\n        return firstFraction.add(secondFraction).add(int256(d2Year.sub(d1Year).sub(1)));\n    }\n\n    /**\n     * ISDA A/360 day count convention\n     */\n    function actualThreeSixty(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(360));\n    }\n\n    /**\n     * ISDA A/365-Fixed day count convention\n     */\n    function actualThreeSixtyFive(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        return (int256((endTime.sub(startTime)).div(86400)).floatDiv(365));\n    }\n\n    /**\n     * ISDA 30E/360 day count convention\n     */\n    function thirtyEThreeSixty(uint256 startTime, uint256 endTime)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Day;\n        uint256 d1Month;\n        uint256 d1Year;\n\n        uint256 d2Day;\n        uint256 d2Month;\n        uint256 d2Year;\n\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\n\n        if (d1Day == 31) {\n            d1Day = 30;\n        }\n\n        if (d2Day == 31) {\n            d2Day = 30;\n        }\n\n        int256 delD = int256(d2Day).sub(int256(d1Day));\n        int256 delM = int256(d2Month).sub(int256(d1Month));\n        int256 delY = int256(d2Year).sub(int256(d1Year));\n\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\n    }\n\n    /**\n     * ISDA 30E/360-ISDA day count convention\n     */\n    function thirtyEThreeSixtyISDA(uint256 startTime, uint256 endTime, uint256 maturityDate)\n        internal\n        pure\n        returns (int256)\n    {\n        uint256 d1Day;\n        uint256 d1Month;\n        uint256 d1Year;\n\n        uint256 d2Day;\n        uint256 d2Month;\n        uint256 d2Year;\n\n        (d1Year, d1Month, d1Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(startTime);\n        (d2Year, d2Month, d2Day) = BokkyPooBahsDateTimeLibrary.timestampToDate(endTime);\n\n        if (d1Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime)) {\n            d1Day = 30;\n        }\n\n        if (!(endTime == maturityDate && d2Month == 2) && d2Day == BokkyPooBahsDateTimeLibrary.getDaysInMonth(endTime)) {\n            d2Day = 30;\n        }\n\n        int256 delD = int256(d2Day).sub(int256(d1Day));\n        int256 delM = int256(d2Month).sub(int256(d1Month));\n        int256 delY = int256(d2Year).sub(int256(d1Year));\n\n        return ((delY.mul(360).add(delM.mul(30)).add(delD)).floatDiv(360));\n    }\n}"
    },
    "openzeppelin-solidity/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/drafts/SignedSafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private INT256_MIN = -2**255;\n\n    /**\n     * @dev Multiplies two signed integers, reverts on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two signed integers, reverts on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two signed integers, reverts on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Core/SignedMath.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\n/**\n * Advanced math library for signed integers\n * (including floats which are represented as multiples of 10 ** 18)\n */\nlibrary SignedMath {\n\n    int256 constant private INT256_MIN = -2 ** 255;\n\n    uint256 constant public PRECISION = 18;\n    uint256 constant public MULTIPLICATOR = 10 ** PRECISION;\n\n\n    /**\n     * @dev The product of a and b has to be less than INT256_MAX (~10 ** 76),\n     * as devision (normalization) is performed after multiplication\n     * Upper boundary would be (10 ** 58) * (MULTIPLICATOR) == ~10 ** 76\n     */\n    function floatMult(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        if (a == 0 || b == 0) return 0;\n\n        require(!(a == -1 && b == INT256_MIN), \"SignedMath.floatMult: OVERFLOW_DETECTED\");\n        int256 c = a * b;\n        require(c / a == b, \"SignedMath.floatMult: OVERFLOW_DETECTED\");\n\n        // normalize (divide by MULTIPLICATOR)\n        int256 d = c / int256(MULTIPLICATOR);\n        require(d != 0, \"SignedMath.floatMult: CANNOT_REPRESENT_GRANULARITY\");\n\n        return d;\n    }\n\n    function floatDiv(int256 a, int256 b)\n        internal\n        pure\n        returns (int256)\n    {\n        require(b != 0, \"SignedMath.floatDiv: DIVIDED_BY_ZERO\");\n\n        // normalize (multiply by MULTIPLICATOR)\n        if (a == 0) return 0;\n        int256 c = a * int256(MULTIPLICATOR);\n        require(c / a == int256(MULTIPLICATOR), \"SignedMath.floatDiv: OVERFLOW_DETECTED\");\n\n        require(!(b == -1 && a == INT256_MIN), \"SignedMath.floatDiv: OVERFLOW_DETECTED\");\n        int256 d = c / b;\n        require(d != 0, \"SignedMath.floatDiv: CANNOT_REPRESENT_GRANULARITY\");\n\n        return d;\n    }\n\n    /**\n        * @dev Returns the smallest of two signed numbers.\n        */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n            return a <= b ? a : b;\n    }\n\n    /**\n        * @dev Returns the largest of two signed numbers.\n        */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n            return a >= b ? a : b;\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Core/Conventions/EndOfMonthConvention.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../../external/BokkyPooBah/BokkyPooBahsDateTimeLibrary.sol\";\n\nimport \"../ACTUSTypes.sol\";\n\n\n/**\n * @title EndOfMonthConvention\n * @notice Implements the ACTUS end of month convention.\n */\ncontract EndOfMonthConvention is ACTUSTypes {\n\n    /**\n     * This function makes an adjustment on the end of month convention.\n     * @dev The following is considered to dertermine if schedule dates are shifted to the end of month:\n     * - The convention SD (same day) means not adjusting, EM (end of month) means adjusting\n     * - Dates are only shifted if the schedule start date is an end-of-month date\n     * - Dates are only shifted if the schedule cycle is based on an \"M\" period unit or multiple thereof\n     * @param eomc the end of month convention to adjust\n     * @param startTime timestamp of the cycle start\n     * @param cycle the cycle struct\n     * @return the adjusted end of month convention\n     */\n    function adjustEndOfMonthConvention(\n        EndOfMonthConvention eomc,\n        uint256 startTime,\n        IPS memory cycle\n    )\n        public\n        pure\n        returns (EndOfMonthConvention)\n    {\n        if (eomc == EndOfMonthConvention.EOM) {\n            // check if startTime is last day in month and schedule has month based period\n            // otherwise switch to SD convention\n            if (\n                BokkyPooBahsDateTimeLibrary.getDay(startTime) == BokkyPooBahsDateTimeLibrary.getDaysInMonth(startTime) &&\n                (cycle.p == P.M || cycle.p == P.Q || cycle.p == P.H)\n            ) {\n                return EndOfMonthConvention.EOM;\n            }\n            return EndOfMonthConvention.SD;\n        } else if (eomc == EndOfMonthConvention.SD) {\n            return EndOfMonthConvention.SD;\n        }\n        revert(\"EndOfMonthConvention.adjustEndOfMonthConvention: ATTRIBUTE_NOT_FOUND.\");\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Engines/BaseEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./IEngine.sol\";\n\n\n/**\n * @title BaseEngine\n * @notice Implements computeStateForEvent and computePayoffForEvent for all Engines.\n * All Engine contracts have to inherit from BaseEngine and implement all abstract methods.\n */\nabstract contract BaseEngine is Core, IEngine {\n\n    /**\n     * Applys an event to the current state of a contract and returns the resulting contract state.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event to be applied to the contract state\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function computeStateForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        return stateTransitionFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * Evaluates the payoff for an event under the current state of the contract.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function computePayoffForEvent(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        public\n        pure\n        override\n        returns (int256)\n    {\n        // if alternative settlementCurrency is set then apply fxRate to payoff\n        if (terms.settlementCurrency != address(0) && terms.currency != terms.settlementCurrency) {\n            return payoffFunction(\n                terms,\n                state,\n                _event,\n                externalData\n            ).floatMult(int256(externalData));\n        }\n\n        return payoffFunction(\n            terms,\n            state,\n            _event,\n            externalData\n        );\n    }\n\n    /**\n     * @notice Abstract method which has to be implemented by the inheriting Engine contract.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        virtual\n        returns (State memory);\n\n    /**\n     * @notice Abstract method which has to be implemented by the inheriting Engine contract.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        virtual\n        returns (int256);\n}"
    },
    "@atpar/actus-solidity/contracts/Engines/STF.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\n\n\n/**\n * @title STF\n * @notice Contains all state transition functions (STFs) currently used by all Engines\n */\ncontract STF is Core {\n\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_NE (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        return state;\n    }\n\n    /**\n     * State transition for PAM analysis events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_AD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM fee payment events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM initial exchange\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.statusDate = scheduleTime;\n\n        state.accruedInterest = terms.accruedInterest;\n\n        // if (terms.cycleAnchorDateOfInterestPayment != 0 &&\n        //   terms.cycleAnchorDateOfInterestPayment < terms.initialExchangeDate\n        // ) {\n        //   state.accruedInterest = state.nominalInterestRate\n        //   .floatMult(state.notionalPrincipal)\n        //   .floatMult(\n        //     yearFraction(\n        //       terms.cycleAnchorDateOfInterestPayment,\n        //       scheduleTime,\n        //       terms.dayCountConvention,\n        //       terms.maturityDate\n        //     )\n        //   );\n        // }\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM interest capitalization\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IPCI (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.notionalPrincipal = state.notionalPrincipal\n        .add(\n            state.accruedInterest\n            .add(\n                state.nominalInterestRate\n                .floatMult(state.notionalPrincipal)\n                .floatMult(timeFromLastEvent)\n            )\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM interest payment\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal prepayment\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal -= 0; // riskFactor(terms.objectCodeOfPrepaymentModel, scheduleTime, state, terms) * state.notionalPrincipal;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal redemption\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM penalty payments\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_PY (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM fixed rate resets\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_RRF (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = terms.nextResetRate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM variable rate resets\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_RR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        // int256 rate = //riskFactor(terms.marketObjectCodeOfRateReset, scheduleTime, state, terms)\n        // \t* terms.rateMultiplier + terms.rateSpread;\n\n        // apply external rate, multiply with rateMultiplier and add the spread\n        int256 rate = int256(uint256(externalData)).floatMult(terms.rateMultiplier).add(terms.rateSpread);\n\n        // deltaRate is the difference between the rate that includes external data, spread and multiplier and the currently active rate from the state\n        int256 deltaRate = rate.sub(state.nominalInterestRate);\n\n        // apply period cap/floor\n        // the deltaRate (the interest rate change) cannot be bigger than the period cap\n        // and not smaller than the period floor\n        // math: deltaRate = min(max(deltaRate, periodFloor),lifeCap)\n        deltaRate = deltaRate.max(terms.periodFloor).min(terms.periodCap);\n        rate = state.nominalInterestRate.add(deltaRate);\n\n        // apply life cap/floor\n        // the rate cannot be higher than the lifeCap\n        // and not smaller than the lifeFloor\n        // math: rate = min(max(rate,lifeFloor),lifeCap)\n        rate = rate.max(terms.lifeFloor).min(terms.lifeCap);\n\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = rate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM scaling index revision events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_SC (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n\n        if ((terms.scalingEffect == ScalingEffect.I00) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.interestScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n        if ((terms.scalingEffect == ScalingEffect._0N0) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.notionalScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM principal redemption\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM termination events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_TD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.nominalInterestRate = 0;\n        state.accruedInterest = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.TD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    /**\n     * State transition for PAM credit events\n     * @param state the old state\n     * @return the new state\n     */\n    function STF_PAM_CE (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(State memory)\n    {\n        uint256 nonPerformingDate = (state.nonPerformingDate == 0)\n            ? shiftEventTime(scheduleTime, terms.businessDayConvention, terms.calendar)\n            : state.nonPerformingDate;\n\n        uint256 currentTimestamp = uint256(externalData);\n\n        bool isInGracePeriod = false;\n        if (terms.gracePeriod.isSet) {\n            uint256 graceDate = getTimestampPlusPeriod(terms.gracePeriod, nonPerformingDate);\n            if (currentTimestamp <= graceDate) {\n                state.contractPerformance = ContractPerformance.DL;\n                isInGracePeriod = true;\n            }\n        }\n\n        if (terms.delinquencyPeriod.isSet && !isInGracePeriod) {\n            uint256 delinquencyDate = getTimestampPlusPeriod(terms.delinquencyPeriod, nonPerformingDate);\n            if (currentTimestamp <= delinquencyDate) {\n                state.contractPerformance = ContractPerformance.DQ;\n            } else {\n                state.contractPerformance = ContractPerformance.DF;\n            }\n        }\n\n        if (state.nonPerformingDate == 0) {\n            state.nonPerformingDate = shiftEventTime(\n                scheduleTime,\n                terms.businessDayConvention,\n                terms.calendar\n            );\n        }\n\n        return state;\n    }\n\n    // function STF_ANN_AD (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    // function STF_ANN_CD (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.ContractPerformance = ContractPerformance.DF;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    // function STF_ANN_FP (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = 0;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_ANN_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.statusDate = scheduleTime;\n\n        state.accruedInterest = terms.accruedInterest;\n\n        // if (terms.cycleAnchorDateOfInterestPayment != 0 &&\n        //   terms.cycleAnchorDateOfInterestPayment < terms.initialExchangeDate\n        // ) {\n        //   state.accruedInterest = state.nominalInterestRate\n        //   .floatMult(state.notionalPrincipal)\n        //   .floatMult(\n        //     yearFraction(\n        //       shiftCalcTime(terms.cycleAnchorDateOfInterestPayment, terms.businessDayConvention, terms.calendar),\n        //       shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n        //       terms.dayCountConvention,\n        //       terms.maturityDate\n        //     )\n        //   );\n        // }\n\n        return state;\n    }\n\n    function STF_ANN_IPCI (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.accruedInterest\n            .add(\n                state.nominalInterestRate\n                .floatMult(state.notionalPrincipal)\n                .floatMult(timeFromLastEvent)\n            )\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = 0;\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // function STF_ANN_PP (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.notionalPrincipal -= 0; // riskFactor(terms.objectCodeOfPrepaymentModel, scheduleTime, state, terms) * state.notionalPrincipal;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_ANN_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = state.notionalPrincipal\n        .sub(\n            roleSign(terms.contractRole)\n            * (\n                roleSign(terms.contractRole)\n                * state.notionalPrincipal\n            )\n            .min(\n                roleSign(terms.contractRole)\n                * (\n                    state.nextPrincipalRedemptionPayment\n                    .sub(state.accruedInterest)\n                )\n            )\n        );\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.notionalPrincipal = 0.0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // STF_PAM_PY\n    // function STF_ANN_PY (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    // function STF_ANN_RRF (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    //   int256 timeFromLastEvent = yearFraction(\n    //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     terms.dayCountConvention,\n    //     terms.maturityDate\n    //   );\n    //   state.nominalAccrued = state.nominalAccrued\n    //   .add(\n    //     state.nominalInterestRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.feeAccrued = state.feeAccrued\n    //   .add(\n    //     terms.feeRate\n    //     .floatMult(state.notionalPrincipal)\n    //     .floatMult(timeFromLastEvent)\n    //   );\n    //   state.nominalInterestRate = terms.nextResetRate;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_ANN_RR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        // int256 rate = //riskFactor(terms.marketObjectCodeOfRateReset, scheduleTime, state, terms)\n        // \t* terms.rateMultiplier + terms.rateSpread;\n        int256 rate = int256(externalData) * terms.rateMultiplier + terms.rateSpread;\n        int256 deltaRate = rate.sub(state.nominalInterestRate);\n\n            // apply period cap/floor\n        if ((terms.lifeCap < deltaRate) && (terms.lifeCap < ((-1) * terms.periodFloor))) {\n            deltaRate = terms.lifeCap;\n        } else if (deltaRate < ((-1) * terms.periodFloor)) {\n            deltaRate = ((-1) * terms.periodFloor);\n        }\n        rate = state.nominalInterestRate.add(deltaRate);\n\n        // apply life cap/floor\n        if (terms.lifeCap < rate && terms.lifeCap < terms.lifeFloor) {\n            rate = terms.lifeCap;\n        } else if (rate < terms.lifeFloor) {\n            rate = terms.lifeFloor;\n        }\n\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.nominalInterestRate = rate;\n        state.nextPrincipalRedemptionPayment = 0; // TODO: implement annuity calculator\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_ANN_SC (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        int256 timeFromLastEvent = yearFraction(\n            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n            terms.dayCountConvention,\n            terms.maturityDate\n        );\n        state.accruedInterest = state.accruedInterest\n        .add(\n            state.nominalInterestRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n        state.feeAccrued = state.feeAccrued\n        .add(\n            terms.feeRate\n            .floatMult(state.notionalPrincipal)\n            .floatMult(timeFromLastEvent)\n        );\n\n        if ((terms.scalingEffect == ScalingEffect.I00) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.interestScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n        if ((terms.scalingEffect == ScalingEffect._0N0) || (terms.scalingEffect == ScalingEffect.IN0)) {\n            state.notionalScalingMultiplier = 0; // riskFactor(terms.marketObjectCodeOfScalingIndex, scheduleTime, state, terms)\n        }\n\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // function STF_ANN_TD (\n    //   uint256 scheduleTime,\n    //   LifecycleTerms memory terms,\n    //   State memory state\n    // )\n    //   internal\n    //   pure\n    //   returns (State memory)\n    // {\n    // //   int256 timeFromLastEvent = yearFraction(\n    // //     shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    // //     shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    // //     terms.dayCountConvention,\n    // //     terms.maturityDate\n    // //   );\n    //   state.notionalPrincipal = 0;\n    //   state.nominalAccrued = 0;\n    //   state.feeAccrued = 0;\n    //   state.statusDate = scheduleTime;\n\n    //   return state;\n    // }\n\n    function STF_CEG_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_XD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.statusDate = scheduleTime;\n        // decode state.notionalPrincipal of underlying from externalData\n        state.exerciseAmount = terms.coverageOfCreditEnhancement.floatMult(int256(externalData));\n        state.exerciseDate = scheduleTime;\n\n        if (terms.feeBasis == FeeBasis.A) {\n            state.feeAccrued = roleSign(terms.contractRole) * terms.feeRate;\n        } else {\n            state.feeAccrued = state.feeAccrued\n                    .add(\n                        yearFraction(\n                            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                            terms.dayCountConvention,\n                            terms.maturityDate\n                        )\n                        .floatMult(terms.feeRate)\n                        .floatMult(state.notionalPrincipal)\n                    );\n        }\n\n        return state;\n    }\n\n    function STF_CEG_STD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = 0;\n        state.feeAccrued = 0;\n        state.contractPerformance = ContractPerformance.MD;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_PRD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.nominalInterestRate = terms.feeRate;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    function STF_CEG_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns (State memory)\n    {\n        state.feeAccrued = 0;\n        state.statusDate = scheduleTime;\n\n        return state;\n    }\n\n    // function STF_CEG_TD (\n    //     LifecycleTerms memory terms,\n    //     State memory state,\n    //     uint256 scheduleTime,\n    //     bytes32 externalData\n    // )\n    //     internal\n    //     pure\n    //     returns (State memory)\n    // {\n    //     // uint256 timeFromLastEvent = yearFraction(\n    //     //   shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n    //     //   shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n    //     //   terms.dayCountConvention,\n    //     //   terms.maturityDate\n    //     // );\n    //     state.notionalPrincipal = 0;\n    //     state.accruedInterest = 0;\n    //     state.feeAccrued = 0;\n    //     state.statusDate = scheduleTime;\n\n    //     return state;\n    // }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Engines/POF.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\n\n\n/**\n * @title POF\n * @notice Contains all payoff functions (POFs) currently used by all Engines\n */\ncontract POF is Core {\n\n    /**\n     * Calculate the pay-off for PAM Fees. The method how to calculate the fee\n     * heavily depends on the selected Fee Basis.\n     * @return the fee amount for PAM contracts\n     */\n    function POF_PAM_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.feeBasis == FeeBasis.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.feeRate\n            );\n        }\n\n        return (\n            state.feeAccrued\n                .add(\n                    yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(terms.feeRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n        );\n    }\n\n    /**\n     * Calculate the payoff for the initial exchange\n     * @return the payoff at iniitial exchange for PAM contracts\n     */\n    function POF_PAM_IED (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * (-1)\n            * terms.notionalPrincipal\n                .add(terms.premiumDiscountAtIED)\n        );\n    }\n\n    /**\n     * Calculate the interest payment payoff\n     * @return the interest amount to pay for PAM contracts\n     */\n    function POF_PAM_IP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            state.interestScalingMultiplier\n                .floatMult(\n                    state.accruedInterest\n                    .add(\n                        yearFraction(\n                            shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                            shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                            terms.dayCountConvention,\n                            terms.maturityDate\n                        )\n                        .floatMult(state.nominalInterestRate)\n                        .floatMult(state.notionalPrincipal)\n                    )\n                )\n        );\n    }\n\n    /**\n     * Calculate the principal prepayment payoff\n     * @return the principal prepayment amount for PAM contracts\n     */\n    function POF_PAM_PP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * state.notionalPrincipal\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of maturity\n     * @return the maturity payoff for PAM contracts\n     */\n    function POF_PAM_MD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            state.notionalScalingMultiplier\n                .floatMult(state.notionalPrincipal)\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of a penalty event\n     * @return the penalty amount for PAM contracts\n     */\n    function POF_PAM_PY (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.penaltyType == PenaltyType.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.penaltyRate\n            );\n        } else if (terms.penaltyType == PenaltyType.N) {\n            return (\n                roleSign(terms.contractRole)\n                * yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(terms.penaltyRate)\n                    .floatMult(state.notionalPrincipal)\n            );\n        } else {\n            return (\n                roleSign(terms.contractRole)\n                * yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(state.notionalPrincipal)\n            );\n        }\n    }\n\n    /**\n     * Calculate the payoff in case of termination of a contract\n     * @return the termination payoff amount for PAM contracts\n     */\n    function POF_PAM_TD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            roleSign(terms.contractRole)\n            * terms.priceAtPurchaseDate\n                .add(state.accruedInterest)\n                .add(\n                    yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(state.nominalInterestRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n        );\n    }\n\n    /**\n     * Calculate the payoff for principal redemption\n     * @dev This is a replacement of the POF_PR_NAM which we have not implemented, yet\n     * @return the principal redemption amount for ANN contracts\n     */\n    function POF_ANN_PR (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return (\n            (state.notionalScalingMultiplier * roleSign(terms.contractRole))\n                .floatMult(\n                    (roleSign(terms.contractRole) * state.notionalPrincipal)\n                    .min(\n                            roleSign(terms.contractRole)\n                            * (\n                                state.nextPrincipalRedemptionPayment\n                                - state.accruedInterest\n                                - yearFraction(\n                                    shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                                    shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                                    terms.dayCountConvention,\n                                    terms.maturityDate\n                                )\n                                .floatMult(state.nominalInterestRate)\n                                .floatMult(state.notionalPrincipal)\n                            )\n                        )\n                )\n        );\n    }\n\n    /**\n     * Calculate the payoff in case of settlement\n     * @return the settlement payoff amount for CEG contracts\n     */\n    function POF_CEG_STD (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        return state.exerciseAmount + state.feeAccrued;\n    }\n\n    /**\n     * Calculate the pay-off for CEG Fees.\n     * @return the fee amount for CEG contracts\n     */\n    function POF_CEG_FP (\n        LifecycleTerms memory terms,\n        State memory state,\n        uint256 scheduleTime,\n        bytes32 externalData\n    )\n        internal\n        pure\n        returns(int256)\n    {\n        if (terms.feeBasis == FeeBasis.A) {\n            return (\n                roleSign(terms.contractRole)\n                * terms.feeRate\n            );\n        }\n\n        return (\n            state.feeAccrued\n                .add(\n                    yearFraction(\n                        shiftCalcTime(state.statusDate, terms.businessDayConvention, terms.calendar),\n                        shiftCalcTime(scheduleTime, terms.businessDayConvention, terms.calendar),\n                        terms.dayCountConvention,\n                        terms.maturityDate\n                    )\n                    .floatMult(terms.feeRate)\n                    .floatMult(state.notionalPrincipal)\n                )\n        );\n    }\n}"
    },
    "@atpar/actus-solidity/contracts/Engines/PAMEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./IEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title PAMEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a PAM contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n */\ncontract PAMEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return the initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.notionalScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.interestScalingMultiplier = int256(1 * 10 ** PRECISION);\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = terms.notionalPrincipal;\n        state.nominalInterestRate = terms.nominalInterestRate;\n        state.accruedInterest = terms.accruedInterest;\n        state.feeAccrued = terms.feeAccrued;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // initial exchange\n        if (terms.purchaseDate == 0 && isInSegment(terms.initialExchangeDate, segmentStart, segmentEnd)) {\n            _eventSchedule[index] = encodeEvent(EventType.IED, terms.initialExchangeDate);\n            index++;\n        }\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                _eventSchedule[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // principal redemption\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd)) {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns(bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        if (eventType == EventType.IP) {\n            uint256 index = 0;\n\n            // interest payment related (covers pre-repayment period only,\n            // starting with PRANX interest is paid following the PR schedule)\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n            ) {\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.maturityDate,\n                    terms.cycleOfInterestPayment,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (interestPaymentSchedule[i] <= terms.capitalizationEndDate) continue;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IP, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.IPCI) {\n            uint256 index = 0;\n\n            // IPCI\n            if (\n                terms.cycleOfInterestPayment.isSet == true\n                && terms.cycleAnchorDateOfInterestPayment != 0\n                && terms.capitalizationEndDate != 0\n            ) {\n                IPS memory cycleOfInterestCapitalization = terms.cycleOfInterestPayment;\n                cycleOfInterestCapitalization.s = S.SHORT;\n\n                uint256[MAX_CYCLE_SIZE] memory interestPaymentSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfInterestPayment,\n                    terms.capitalizationEndDate,\n                    cycleOfInterestCapitalization,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (interestPaymentSchedule[i] == 0) break;\n                    if (isInSegment(interestPaymentSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.IPCI, interestPaymentSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.RR) {\n            uint256 index = 0;\n\n            // rate reset\n            if (terms.cycleOfRateReset.isSet == true && terms.cycleAnchorDateOfRateReset != 0) {\n                uint256[MAX_CYCLE_SIZE] memory rateResetSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfRateReset,\n                    terms.maturityDate,\n                    terms.cycleOfRateReset,\n                    false,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (rateResetSchedule[i] == 0) break;\n                    if (isInSegment(rateResetSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.RR, rateResetSchedule[i]);\n                    index++;\n                }\n            }\n            // ... nextRateReset\n        }\n\n        if (eventType == EventType.FP) {\n            uint256 index = 0;\n\n            // fees\n            if (terms.cycleOfFee.isSet == true && terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        if (eventType == EventType.SC) {\n            uint256 index;\n\n            // scaling\n            if ((terms.scalingEffect != ScalingEffect._000)\n                && terms.cycleAnchorDateOfScalingIndex != 0\n            ) {\n                uint256[MAX_CYCLE_SIZE] memory scalingSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfScalingIndex,\n                    terms.maturityDate,\n                    terms.cycleOfScalingIndex,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (scalingSchedule[i] == 0) break;\n                    if (isInSegment(scalingSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.SC, scalingSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * todo Annuity calculator for RR/RRF events, IPCB events and ICB state variable\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n        /*\n         * Note:\n         * Not supported: PRD events\n         */\n        if (eventType == EventType.AD) return STF_PAM_AD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_PAM_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IED) return STF_PAM_IED(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IPCI) return STF_PAM_IPCI(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.IP) return STF_PAM_IP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PP) return STF_PAM_PP(terms, state, scheduleTime, externalData);\n        //if (eventType == EventType.PRD) return STF_PAM_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_PAM_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.PY) return STF_PAM_PY(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RRF) return STF_PAM_RRF(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.RR) return STF_PAM_RR(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.SC) return STF_PAM_SC(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.TD) return STF_PAM_TD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE)  return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"PAMEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * todo IPCB events and Icb state variable, Icb state variable updates in IP-paying events\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        /*\n         * Note: PAM contracts don't have IPCB and PR events.\n         * Not supported: PRD events\n         */\n\n        if (eventType == EventType.AD) return 0; // Analysis Event\n        if (eventType == EventType.IPCI) return 0; // Interest Capitalization Event\n        if (eventType == EventType.RRF) return 0; // Rate Reset Fixed\n        if (eventType == EventType.RR) return 0; // Rate Reset Variable\n        if (eventType == EventType.SC) return 0; // Scaling Index Revision\n        if (eventType == EventType.CE) return 0; // Credit Event\n        if (eventType == EventType.FP) return POF_PAM_FP(terms, state, scheduleTime, externalData); // Fee Payment\n        if (eventType == EventType.IED) return POF_PAM_IED(terms, state, scheduleTime, externalData); // Intital Exchange\n        if (eventType == EventType.IP) return POF_PAM_IP(terms, state, scheduleTime, externalData); // Interest Payment\n        if (eventType == EventType.PP) return POF_PAM_PP(terms, state, scheduleTime, externalData); // Principal Prepayment\n        //if (eventType == EventType.PRD) return POF_PAM_PRD(terms, state, scheduleTime, externalData); // Purchase\n        if (eventType == EventType.MD) return POF_PAM_MD(terms, state, scheduleTime, externalData); // Maturity\n        if (eventType == EventType.PY) return POF_PAM_PY(terms, state, scheduleTime, externalData); // Penalty Payment\n        if (eventType == EventType.TD) return POF_PAM_TD(terms, state, scheduleTime, externalData); // Termination\n\n        revert(\"PAMEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "@atpar/actus-solidity/contracts/Engines/CEGEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./IEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title CEGEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a CEC contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n * inputs have to be multiplied by 10 ** 18, outputs have to multplied by 10 ** -18\n */\ncontract CEGEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n        state.feeAccrued = terms.feeAccrued;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // purchase\n        if (terms.purchaseDate != 0) {\n            if (isInSegment(terms.purchaseDate, segmentStart, segmentEnd)) {\n                _eventSchedule[index] = encodeEvent(EventType.PRD, terms.purchaseDate);\n                index++;\n            }\n        }\n\n        // maturity event\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true) {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        if (eventType == EventType.FP) {\n            uint256 index = 0;\n\n            // fees\n            if (terms.cycleOfFee.isSet == true && terms.cycleAnchorDateOfFee != 0) {\n                uint256[MAX_CYCLE_SIZE] memory feeSchedule = computeDatesFromCycleSegment(\n                    terms.cycleAnchorDateOfFee,\n                    terms.maturityDate,\n                    terms.cycleOfFee,\n                    true,\n                    segmentStart,\n                    segmentEnd\n                );\n                for (uint8 i = 0; i < MAX_CYCLE_SIZE; i++) {\n                    if (feeSchedule[i] == 0) break;\n                    if (isInSegment(feeSchedule[i], segmentStart, segmentEnd) == false) continue;\n                    _eventSchedule[index] = encodeEvent(EventType.FP, feeSchedule[i]);\n                    index++;\n                }\n            }\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (hasUnderlying) {\n            // FP, MD events only scheduled up to execution of the Guarantee\n            if (\n                (eventType == EventType.FP || eventType == EventType.MD)\n                && underlyingState.exerciseAmount > int256(0)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n        // PRD events not supported\n        //if (eventType == EventType.PRD) return STF_CEG_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return STF_CEG_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.XD) return STF_CEG_XD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.STD) return STF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_CEG_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"CEGEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        // PRD events not supported\n        if (eventType == EventType.CE) return 0;\n        // if (eventType == EventType.PRD) return POF_CEG_PRD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.FP) return POF_CEG_FP(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.XD) return 0;\n        if (eventType == EventType.STD) return POF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return 0;\n        \n        revert(\"CEGEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}"
    },
    "@atpar/actus-solidity/contracts/Engines/CECEngine.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/Core.sol\";\nimport \"./BaseEngine.sol\";\nimport \"./IEngine.sol\";\nimport \"./STF.sol\";\nimport \"./POF.sol\";\n\n\n/**\n * @title CECEngine\n * @notice Inherits from BaseEngine by implementing STFs, POFs according to the ACTUS standard for a CEC contract\n * @dev All numbers except unix timestamp are represented as multiple of 10 ** 18\n * inputs have to be multiplied by 10 ** 18, outputs have to multplied by 10 ** -18\n */\ncontract CECEngine is BaseEngine, STF, POF {\n\n    /**\n     * @notice Initialize contract state space based on the contract terms.\n     * @param terms terms of the contract\n     * @return initial state of the contract\n     */\n    function computeInitialState(LifecycleTerms memory terms)\n        public\n        pure\n        override\n        returns (State memory)\n    {\n        State memory state;\n\n        state.contractPerformance = ContractPerformance.PF;\n        state.statusDate = terms.statusDate;\n        state.maturityDate = terms.maturityDate;\n        state.notionalPrincipal = roleSign(terms.contractRole) * terms.notionalPrincipal;\n\n        return state;\n    }\n\n    /**\n     * @notice Computes a schedule segment of non-cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @return segment of the non-cyclic schedule\n     */\n    function computeNonCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n        uint16 index = 0;\n\n        // maturity event\n        if (isInSegment(terms.maturityDate, segmentStart, segmentEnd) == true) {\n            _eventSchedule[index] = encodeEvent(EventType.MD, terms.maturityDate);\n            index++;\n        }\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Computes a schedule segment of cyclic contract events based on the contract terms\n     * and the specified timestamps.\n     * @param terms terms of the contract\n     * @param segmentStart start timestamp of the segment\n     * @param segmentEnd end timestamp of the segement\n     * @param eventType eventType of the cyclic schedule\n     * @return event schedule segment\n     */\n    function computeCyclicScheduleSegment(\n        GeneratingTerms memory terms,\n        uint256 segmentStart,\n        uint256 segmentEnd,\n        EventType eventType\n    )\n        public\n        pure\n        override\n        returns (bytes32[MAX_EVENT_SCHEDULE_SIZE] memory)\n    {\n        bytes32[MAX_EVENT_SCHEDULE_SIZE] memory _eventSchedule;\n\n        return _eventSchedule;\n    }\n\n    /**\n     * @notice Verifies that the provided event is still scheduled under the terms, the current state of the\n     * contract and the current state of the underlying.\n     * @param _event event for which to check if its still scheduled\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param hasUnderlying boolean indicating whether the contract has an underlying contract\n     * @param underlyingState state of the underlying (empty state object if non-existing)\n     * @return boolean indicating whether event is still scheduled\n     */\n    function isEventScheduled(\n        bytes32 _event,\n        LifecycleTerms memory terms,\n        State memory state,\n        bool hasUnderlying,\n        State memory underlyingState\n    )\n        public\n        pure\n        override\n        returns (bool)\n    {\n        return true;\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Applies an event to the current state of the contract and returns the resulting state.\n     * The inheriting Engine contract has to map the events type to the designated STF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which to evaluate the next state for\n     * @param externalData external data needed for STF evaluation (e.g. rate for RR events)\n     * @return the resulting contract state\n     */\n    function stateTransitionFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (State memory)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.XD) return STF_CEG_XD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return STF_CEG_MD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.STD) return STF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.CE) return STF_PAM_CE(terms, state, scheduleTime, externalData);\n\n        revert(\"CECEngine.stateTransitionFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n\n    /**\n     * @notice Implements abstract method which is defined in BaseEngine.\n     * Computes the payoff for an event under the current state of the contract.\n     * The inheriting Engine contract has to map the events type to the designated POF.\n     * @param terms terms of the contract\n     * @param state current state of the contract\n     * @param _event event for which the payoff should be evaluated\n     * @param externalData external data needed for POF evaluation (e.g. fxRate)\n     * @return the payoff of the event\n     */\n    function payoffFunction(\n        LifecycleTerms memory terms,\n        State memory state,\n        bytes32 _event,\n        bytes32 externalData\n    )\n        internal\n        pure\n        override\n        returns (int256)\n    {\n        (EventType eventType, uint256 scheduleTime) = decodeEvent(_event);\n\n        if (eventType == EventType.CE) return 0;\n        if (eventType == EventType.XD) return 0;\n        if (eventType == EventType.STD) return POF_CEG_STD(terms, state, scheduleTime, externalData);\n        if (eventType == EventType.MD) return 0;\n\n        revert(\"CECEngine.payoffFunction: ATTRIBUTE_NOT_FOUND\");\n    }\n}\n"
    },
    "contracts/Issuance/AssetIssuer.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/SharedTypes.sol\";\nimport \"../Core/Conversions.sol\";\nimport \"../Core/TemplateRegistry/ITemplateRegistry.sol\";\nimport \"../Core/AssetRegistry/IAssetRegistry.sol\";\nimport \"../Core/AssetActor/IAssetActor.sol\";\nimport \"./IAssetIssuer.sol\";\nimport \"./ICustodian.sol\";\nimport \"./VerifyOrder.sol\";\n\n\n/**\n * @title AssetIssuer\n * @notice Contract for issuing ACTUS assets. Currently supports the issuance of\n * independent assets as well as assets with up to two enhancements (such as Guarantee and Collateral).\n */\ncontract AssetIssuer is\n    SharedTypes,\n    Conversions,\n    VerifyOrder,\n    IAssetIssuer\n{\n    event ExecutedOrder(bytes32 indexed orderId, bytes32 assetId);\n    event IssuedAsset(bytes32 indexed assetId, address indexed creator, address indexed counterparty);\n\n    ICustodian public custodian;\n    ITemplateRegistry public templateRegistry;\n    IAssetRegistry public assetRegistry;\n    IAssetActor public assetActor;\n\n\n    constructor(\n        ICustodian _custodian,\n        ITemplateRegistry _templateRegistry,\n        IAssetRegistry _assetRegistry,\n        IAssetActor _assetActor\n    )\n        public\n    {\n        custodian = _custodian;\n        templateRegistry = _templateRegistry;\n        assetRegistry = _assetRegistry;\n        assetActor = _assetActor;\n    }\n\n    function issueFromDraft(Draft memory draft)\n        public\n        override\n    {\n        (\n            bytes32 assetId,\n            AssetOwnership memory ownership,\n            bytes32 templateId,\n            CustomTerms memory customTerms,\n            address engine,\n            address admin\n        ) = finalizeDraft(draft);\n\n        issueAsset(\n            assetId, ownership, templateId, customTerms, engine, admin\n        );\n    }\n\n    function finalizeDraft(Draft memory draft)\n        internal\n        returns (bytes32, AssetOwnership memory, bytes32, CustomTerms memory, address, address)\n    {\n        bytes32 assetId = keccak256(abi.encode(draft.termsHash, block.timestamp));\n\n        // check if first contract reference in terms references an underlying asset\n        if (draft.customTerms.overwrittenTerms.contractReference_1.role == ContractReferenceRole.COVE) {\n            require(\n                draft.customTerms.overwrittenTerms.contractReference_1.object != bytes32(0),\n                \"AssetIssuer.finalizeDraft: INVALID_OBJECT\"\n            );\n        }\n\n        // check if second contract reference in terms contains a reference to collateral\n        if (draft.customTerms.overwrittenTerms.contractReference_2.role == ContractReferenceRole.COVI) {\n            require(\n                draft.customTerms.overwrittenTerms.contractReference_2.object != bytes32(0),\n                \"AssetIssuer.finalizeDraft: INVALID_OBJECT\"\n            );\n\n            // derive assetId and terms of draft from template terms and custom terms\n            assetId = keccak256(abi.encode(draft.termsHash, address(custodian), block.timestamp));\n            LifecycleTerms memory terms = deriveLifecycleTermsFromCustomTermsAndTemplateTerms(\n                templateRegistry.getTemplateTerms(draft.templateId),\n                draft.customTerms\n            );\n\n            // derive underlying assetId\n            bytes32 underlyingAssetId = draft.customTerms.overwrittenTerms.contractReference_1.object;\n            // get terms and ownership of referenced underlying asset\n            LifecycleTerms memory underlyingTerms = assetRegistry.getTerms(underlyingAssetId);\n            AssetOwnership memory underlyingOwnership = assetRegistry.getOwnership(underlyingAssetId);\n\n            // set ownership of draft according to contract role of underlying\n            if (terms.contractRole == ContractRole.BUY && underlyingTerms.contractRole == ContractRole.RPA) {\n                draft.ownership = AssetOwnership(\n                    underlyingOwnership.creatorObligor,\n                    underlyingOwnership.creatorBeneficiary,\n                    address(custodian),\n                    underlyingOwnership.counterpartyBeneficiary\n                );\n            } else if (terms.contractRole == ContractRole.SEL && underlyingTerms.contractRole == ContractRole.RPL) {\n                draft.ownership = AssetOwnership(\n                    address(custodian),\n                    underlyingOwnership.creatorBeneficiary,\n                    underlyingOwnership.counterpartyObligor,\n                    underlyingOwnership.counterpartyBeneficiary\n                );\n            } else {\n                // only BUY, RPA and SEL, RPL allowed for CEC\n                revert(\"AssetIssuer.finalizeDraft: INVALID_CONTRACT_ROLES\");\n            }\n\n            // execute contractual conditions\n            // try transferring collateral to the custodian\n            custodian.lockCollateral(assetId, terms, draft.ownership);\n        }\n\n        return (\n            assetId,\n            draft.ownership,\n            draft.templateId,\n            draft.customTerms,\n            draft.engine,\n            draft.admin\n        );\n    }\n\n    /**\n     * @notice Issues an asset from an order which was signed by the creator obligor and the counterparty obligor.\n     * @dev verifies both signatures and initializes by calling the asset actor,\n     * If ownership is undefined and signatures are undefined it skips signature verification.\n     * (required if a Collateral enhancement is present)\n     * @param order order for which to issue the asset\n     */\n    function issueFromOrder(Order memory order)\n        public\n        override\n    {\n        // verify signatures of order (and enhancement orders)\n        require(\n            assertOrderSignatures(order),\n            \"AssetIssuer.issueFromOrder: INVALID_SIGNATURE\"\n        );\n\n        // issue asset (underlying)\n        (\n            bytes32 assetId,\n            AssetOwnership memory ownership,\n            bytes32 templateId,\n            CustomTerms memory customTerms,\n            address engine,\n            address admin\n        ) = finalizeOrder(order);\n\n        issueAsset(\n            assetId, ownership, templateId, customTerms, engine, admin\n        );\n\n        // check if first enhancement order is specified\n        if (order.enhancementOrder_1.termsHash != bytes32(0)) {\n            (\n                bytes32 assetId,\n                AssetOwnership memory ownership,\n                bytes32 templateId,\n                CustomTerms memory customTerms,\n                address engine,\n                address admin\n            ) = finalizeEnhancementOrder(order.enhancementOrder_1, order);\n\n            issueAsset(\n                assetId, ownership, templateId, customTerms, engine, admin\n            );\n        }\n\n        // check if second enhancement order is specified\n        if (order.enhancementOrder_2.termsHash != bytes32(0)) {\n            (\n                bytes32 assetId,\n                AssetOwnership memory ownership,\n                bytes32 templateId,\n                CustomTerms memory customTerms,\n                address engine,\n                address admin\n            ) = finalizeEnhancementOrder(order.enhancementOrder_2, order);\n\n            issueAsset(\n                assetId, ownership, templateId, customTerms, engine, admin\n            );\n        }\n\n        emit ExecutedOrder(keccak256(abi.encode(order.creatorSignature)), assetId);\n    }\n\n    /**\n     * @notice Executes all pre-issuance conditions (e.g. collateral requirements)\n     * defined in the contract references of the order and sets the final ownership of the asset\n     */\n    function finalizeOrder(Order memory order)\n        internal\n        returns (bytes32, AssetOwnership memory, bytes32, CustomTerms memory, address, address)\n    {\n        bytes32 assetId = keccak256(abi.encode(order.creatorSignature, order.counterpartySignature));\n\n        // check if first contract reference in terms references an underlying asset\n        if (order.customTerms.overwrittenTerms.contractReference_1.role == ContractReferenceRole.COVE) {\n            require(\n                order.customTerms.overwrittenTerms.contractReference_1.object != bytes32(0),\n                \"AssetIssuer.finalizeOrder: INVALID_OBJECT\"\n            );\n        }\n\n        // check if second contract reference in terms contains a reference to collateral\n        if (order.customTerms.overwrittenTerms.contractReference_2.role == ContractReferenceRole.COVI) {\n            require(\n                order.customTerms.overwrittenTerms.contractReference_2.object != bytes32(0),\n                \"AssetIssuer.finalizeOrder: INVALID_OBJECT\"\n            );\n\n            // derive assetId and terms of order from template terms and custom terms\n            assetId = keccak256(abi.encode(order.termsHash, address(custodian), order.salt));\n            LifecycleTerms memory terms = deriveLifecycleTermsFromCustomTermsAndTemplateTerms(\n                templateRegistry.getTemplateTerms(order.templateId),\n                order.customTerms\n            );\n\n            // derive underlying assetId\n            bytes32 underlyingAssetId = order.customTerms.overwrittenTerms.contractReference_1.object;\n            // get terms and ownership of referenced underlying asset\n            LifecycleTerms memory underlyingTerms = assetRegistry.getTerms(underlyingAssetId);\n            AssetOwnership memory underlyingOwnership = assetRegistry.getOwnership(underlyingAssetId);\n\n            // set ownership of order according to contract role of underlying\n            if (terms.contractRole == ContractRole.BUY && underlyingTerms.contractRole == ContractRole.RPA) {\n                order.ownership = AssetOwnership(\n                    underlyingOwnership.creatorObligor,\n                    underlyingOwnership.creatorBeneficiary,\n                    address(custodian),\n                    underlyingOwnership.counterpartyBeneficiary\n                );\n            } else if (terms.contractRole == ContractRole.SEL && underlyingTerms.contractRole == ContractRole.RPL) {\n                order.ownership = AssetOwnership(\n                    address(custodian),\n                    underlyingOwnership.creatorBeneficiary,\n                    underlyingOwnership.counterpartyObligor,\n                    underlyingOwnership.counterpartyBeneficiary\n                );\n            } else {\n                // only BUY, RPA and SEL, RPL allowed for CEC\n                revert(\"AssetIssuer.finalizeOrder: INVALID_CONTRACT_ROLES\");\n            }\n\n            // execute contractual conditions\n            // try transferring collateral to the custodian\n            custodian.lockCollateral(assetId, terms, order.ownership);\n        }\n\n        return (\n            assetId,\n            order.ownership,\n            order.templateId,\n            order.customTerms,\n            order.engine,\n            order.admin\n        );\n    }\n\n    /**\n     * @notice Executes all pre-issuance conditions (e.g. collateral requirements)\n     * defined in the contract references of the enhancement order and sets the final ownership of the enhancement\n     */\n    function finalizeEnhancementOrder(EnhancementOrder memory enhancementOrder, Order memory order)\n        internal\n        returns (bytes32, AssetOwnership memory, bytes32, CustomTerms memory, address, address)\n    {\n        bytes32 assetId = keccak256(abi.encode(enhancementOrder.creatorSignature, enhancementOrder.counterpartySignature));\n\n        // check if first contract reference in enhancement terms references an underlying asset\n        if (enhancementOrder.customTerms.overwrittenTerms.contractReference_1.role == ContractReferenceRole.COVE) {\n            // derive assetId of underlying and set as object in the first contract reference\n            enhancementOrder.customTerms.overwrittenTerms.contractReference_1.object = keccak256(\n                abi.encode(order.creatorSignature, order.counterpartySignature)\n            );\n        }\n\n        // check if second contract reference in enhancement terms contain a reference to collateral\n        if (enhancementOrder.customTerms.overwrittenTerms.contractReference_2.role == ContractReferenceRole.COVI) {\n            // derive assetId\n            assetId = keccak256(abi.encode(order.creatorSignature, order.counterpartySignature, address(custodian)));\n\n            // derive terms of underlying from template terms and custom terms\n            LifecycleTerms memory underlyingTerms = deriveLifecycleTermsFromCustomTermsAndTemplateTerms(\n                templateRegistry.getTemplateTerms(order.templateId),\n                order.customTerms\n            );\n            // derive terms of enhancement from template terms and custom terms\n            LifecycleTerms memory enhancementTerms = deriveLifecycleTermsFromCustomTermsAndTemplateTerms(\n                templateRegistry.getTemplateTerms(enhancementOrder.templateId),\n                enhancementOrder.customTerms\n            );\n\n            // set ownership of enhancement according to contract role of underlying\n            if (enhancementTerms.contractRole == ContractRole.BUY && underlyingTerms.contractRole == ContractRole.RPA) {\n                enhancementOrder.ownership = AssetOwnership(\n                    order.ownership.creatorObligor,\n                    order.ownership.creatorBeneficiary,\n                    address(custodian),\n                    order.ownership.counterpartyBeneficiary\n                );\n            } else if (enhancementTerms.contractRole == ContractRole.SEL && underlyingTerms.contractRole == ContractRole.RPL) {\n                enhancementOrder.ownership = AssetOwnership(\n                    address(custodian),\n                    order.ownership.creatorBeneficiary,\n                    order.ownership.counterpartyObligor,\n                    order.ownership.counterpartyBeneficiary\n                );\n            } else {\n                // only BUY, RPA and SEL, RPL allowed for CEC\n                revert(\"AssetIssuer.finalizeEnhancementOrder: INVALID_CONTRACT_ROLES\");\n            }\n\n            // execute contractual conditions\n            require(\n                enhancementTerms.contractReference_2.object != bytes32(0),\n                \"AssetIssuer.finalizeEnhancementOrder: INVALID_OBJECT\"\n            );\n            // try transferring collateral to the custodian\n            custodian.lockCollateral(assetId, enhancementTerms, enhancementOrder.ownership);\n        }\n\n        return (\n            assetId,\n            enhancementOrder.ownership,\n            enhancementOrder.templateId,\n            enhancementOrder.customTerms,\n            enhancementOrder.engine,\n            enhancementOrder.admin\n        );\n    }\n\n    function issueAsset(\n        bytes32 assetId,\n        AssetOwnership memory ownership,\n        bytes32 templateId,\n        CustomTerms memory customTerms,\n        address engine,\n        address admin\n    )\n        internal\n    {\n        // initialize the asset by calling the asset actor\n        require(\n            assetActor.initialize(\n                assetId,\n                ownership,\n                templateId,\n                customTerms,\n                engine,\n                admin\n            ),\n            \"AssetIssuer.issueAsset: EXECUTION_ERROR\"\n        );\n\n        emit IssuedAsset(assetId, ownership.creatorObligor, ownership.counterpartyObligor);\n    }\n}\n"
    },
    "contracts/Issuance/IAssetIssuer.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/SharedTypes.sol\";\nimport \"../Core/AssetActor/IAssetActor.sol\";\nimport \"./VerifyOrder.sol\";\n\n\nabstract contract IAssetIssuer is SharedTypes, VerifyOrder {\n\n    struct Draft {\n        bytes32 termsHash;\n        bytes32 templateId;\n        CustomTerms customTerms;\n        AssetOwnership ownership;\n        address engine;\n        address admin;\n    }\n\n\n    function issueFromDraft(Draft memory draft)\n        public\n        virtual;\n\n    function issueFromOrder(Order memory order)\n        public\n        virtual;\n}\n"
    },
    "contracts/Issuance/VerifyOrder.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\n\nimport \"../Core/SharedTypes.sol\";\n\n\n/**\n * @title VerifyOrder\n * @notice Contract for verifying order signature according to ERC712\n */\ncontract VerifyOrder is SharedTypes {\n\n    struct EIP712Domain {\n        string name;\n        string version;\n        uint256 chainId;\n        address verifyingContract;\n    }\n\n    struct EnhancementOrder {\n        bytes32 termsHash;\n        bytes32 templateId;\n        CustomTerms customTerms;\n        AssetOwnership ownership;\n        address engine;\n        address admin;\n        bytes creatorSignature;\n        bytes counterpartySignature;\n        uint256 salt;\n    }\n\n    struct Order {\n        bytes32 termsHash;\n        bytes32 templateId;\n        CustomTerms customTerms;\n        uint256 expirationDate;\n        AssetOwnership ownership;\n        address engine;\n        address admin;\n        EnhancementOrder enhancementOrder_1;\n        EnhancementOrder enhancementOrder_2;\n        bytes creatorSignature;\n        bytes counterpartySignature;\n        uint256 salt;\n    }\n\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n    );\n\n    // signed by the creator of the Order which includes the Enhancement Order\n    bytes32 constant DRAFT_ENHANCEMENT_ORDER_TYPEHASH = keccak256(\n        \"EnhancementOrder(bytes32 termsHash,bytes32 templateId,bytes32 customTermsHash,address engine,address admin,uint256 salt)\"\n    );\n\n    bytes32 constant ENHANCEMENT_ORDER_TYPEHASH = keccak256(\n        \"EnhancementOrder(bytes32 termsHash,bytes32 templateId,bytes32 customTermsHash,bytes32 ownershipHash,address engine,address admin,uint256 salt)\"\n    );\n\n    bytes32 constant ORDER_TYPEHASH = keccak256(\n        \"Order(bytes32 termsHash,bytes32 templateId,bytes32 customTermsHash,uint256 expirationDate,bytes32 ownershipHash,address engine,address admin,bytes32 enhancementOrderHash_1,bytes32 enhancementOrderHash_2,uint256 salt)\"\n    );\n\n    bytes32 DOMAIN_SEPARATOR;\n\n\n    constructor () public {\n        DOMAIN_SEPARATOR = hashEIP712Domain(\n            EIP712Domain({\n                name: \"ACTUS Protocol\",\n                version: \"1\",\n                chainId: 0,\n                verifyingContract: address(this)\n            })\n        );\n    }\n\n    function hashEIP712Domain(EIP712Domain memory eip712Domain)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(bytes(eip712Domain.name)),\n                keccak256(bytes(eip712Domain.version)),\n                eip712Domain.chainId,\n                eip712Domain.verifyingContract\n            )\n        );\n    }\n\n    function hashCustomTerms(CustomTerms memory terms)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(terms));\n    }\n\n    function hashOwnership(AssetOwnership memory ownership)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(ownership));\n    }\n\n    function hashDraftEnhancementOrder(EnhancementOrder memory enhancementOrder)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                DRAFT_ENHANCEMENT_ORDER_TYPEHASH,\n                enhancementOrder.termsHash,\n                enhancementOrder.templateId,\n                hashCustomTerms(enhancementOrder.customTerms),\n                enhancementOrder.engine,\n                enhancementOrder.admin,\n                enhancementOrder.salt\n            )\n        );\n    }\n\n    function hashUnfilledEnhancementOrder(EnhancementOrder memory enhancementOrder)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                ENHANCEMENT_ORDER_TYPEHASH,\n                enhancementOrder.termsHash,\n                enhancementOrder.templateId,\n                hashCustomTerms(enhancementOrder.customTerms),\n                hashOwnership(\n                    AssetOwnership(\n                        enhancementOrder.ownership.creatorObligor,\n                        enhancementOrder.ownership.creatorBeneficiary,\n                        address(0),\n                        address(0)\n                    )\n                ),\n                enhancementOrder.engine,\n                enhancementOrder.admin,\n                enhancementOrder.salt\n            )\n        );\n    }\n\n    function hashFilledEnhancementOrder(EnhancementOrder memory enhancementOrder)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                ENHANCEMENT_ORDER_TYPEHASH,\n                enhancementOrder.termsHash,\n                enhancementOrder.templateId,\n                hashCustomTerms(enhancementOrder.customTerms),\n                hashOwnership(enhancementOrder.ownership),\n                enhancementOrder.engine,\n                enhancementOrder.admin,\n                enhancementOrder.salt\n            )\n        );\n    }\n\n    function hashUnfilledOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                ORDER_TYPEHASH,\n                order.termsHash,\n                order.templateId,\n                hashCustomTerms(order.customTerms),\n                order.expirationDate,\n                hashOwnership(\n                    AssetOwnership(\n                        order.ownership.creatorObligor,\n                        order.ownership.creatorBeneficiary,\n                        address(0),\n                        address(0)\n                    )\n                ),\n                order.engine,\n                order.admin,\n                hashDraftEnhancementOrder(order.enhancementOrder_1),\n                hashDraftEnhancementOrder(order.enhancementOrder_2),\n                order.salt\n            )\n        );\n    }\n\n    function hashFilledOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encode(\n                ORDER_TYPEHASH,\n                order.termsHash,\n                order.templateId,\n                hashCustomTerms(order.customTerms),\n                order.expirationDate,\n                hashOwnership(order.ownership),\n                order.engine,\n                order.admin,\n                hashDraftEnhancementOrder(order.enhancementOrder_1),\n                hashDraftEnhancementOrder(order.enhancementOrder_2),\n                order.salt\n            )\n        );\n    }\n\n    /**\n     * @notice Verifies the signature of the Order with all Enhancement Orders.\n     * The creator and counterparty signatures of the parent Order (or just Order)\n     * are verified using the hash of the drafted version of the enhancement orders\n     * in order to verify that the terms of the Enhancement Order where not changed.\n     * The signatures of the Enhancement Orders are verified on their own.\n     */\n    function assertOrderSignatures(Order memory order)\n        internal\n        view\n        returns (bool)\n    {\n        // verify signatures of Order\n        bytes32 creatorOrderDigest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashUnfilledOrder(order)\n            )\n        );\n        bytes32 counterpartyOrderDigest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashFilledOrder(order)\n            )\n        );\n\n        if (\n            ECDSA.recover(\n                creatorOrderDigest,\n                order.creatorSignature\n            ) != order.ownership.creatorObligor\n        ) { return false; }\n        if (\n            ECDSA.recover(\n                counterpartyOrderDigest,\n                order.counterpartySignature\n            ) != order.ownership.counterpartyObligor\n        ) { return false; }\n\n\n        // verify signature of first Enhancement Order\n        bytes32 creatorEnhancementOrderDigest_1 = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashUnfilledEnhancementOrder(order.enhancementOrder_1)\n            )\n        );\n        bytes32 counterpartyEnhancementOrderDigest_1 = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashFilledEnhancementOrder(order.enhancementOrder_1)\n            )\n        );\n\n        if (\n            ECDSA.recover(\n                creatorEnhancementOrderDigest_1,\n                order.enhancementOrder_1.creatorSignature\n            ) != order.enhancementOrder_1.ownership.creatorObligor\n        ) { return false; }\n        if (\n            ECDSA.recover(\n                counterpartyEnhancementOrderDigest_1,\n                order.enhancementOrder_1.counterpartySignature\n            ) != order.enhancementOrder_1.ownership.counterpartyObligor\n        ) { return false; }\n\n\n        // verify signature of second Enhancement Order\n        bytes32 creatorEnhancementOrderDigest_2 = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashUnfilledEnhancementOrder(order.enhancementOrder_2)\n            )\n        );\n        bytes32 counterpartyEnhancementOrderDigest_2 = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashFilledEnhancementOrder(order.enhancementOrder_2)\n            )\n        );\n\n        if (\n            ECDSA.recover(\n                creatorEnhancementOrderDigest_2,\n                order.enhancementOrder_2.creatorSignature\n            ) != order.enhancementOrder_2.ownership.creatorObligor\n        ) { return false; }\n        if (\n            ECDSA.recover(\n                counterpartyEnhancementOrderDigest_2,\n                order.enhancementOrder_2.counterpartySignature\n            ) != order.enhancementOrder_2.ownership.counterpartyObligor\n        ) { return false; }\n\n        return true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * NOTE: This call _does not revert_ if the signature is invalid, or\n     * if the signer is otherwise unable to be retrieved. In those scenarios,\n     * the zero address is returned.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 && v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/Issuance/ICustodian.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"../Core/SharedTypes.sol\";\n\n\nabstract contract ICustodian is SharedTypes {\n\n    function lockCollateral(\n        bytes32 assetId,\n        LifecycleTerms memory terms,\n        AssetOwnership memory ownership\n    )\n        public\n        virtual\n        returns (bool);\n\n    function returnCollateral(\n        bytes32 assetId\n    )\n        public\n        virtual\n        returns (bool);\n}"
    },
    "contracts/Issuance/Custodian.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"../Core/Conversions.sol\";\nimport \"../Core/AssetRegistry/IAssetRegistry.sol\";\nimport \"./ICustodian.sol\";\n\n\n/**\n * @title Custodian\n * @notice Contract which holds the collateral of CEC (Credit Enhancement Collateral) assets.\n */\ncontract Custodian is ICustodian, ReentrancyGuard, Conversions {\n\n    using SafeMath for uint256;\n\n    event LockedCollateral(bytes32 indexed assetId, address collateralizer, uint256 collateralAmount);\n    event ReturnedCollateral(bytes32 indexed assetId, address collateralizer, uint256 returnedAmount);\n\n    address public assetActor;\n    IAssetRegistry public assetRegistry;\n    mapping(bytes32 => bool) collateral;\n\n\n    constructor(address _assetActor, IAssetRegistry _assetRegistry) public {\n        assetActor = _assetActor;\n        assetRegistry = _assetRegistry;\n    }\n\n    /**\n     * @notice Locks the required collateral amount encoded in the second contract\n     * reference in the terms.\n     * @dev The collateralizer has to set allowance beforehand. The custodian increases\n     * allowance for the AssetActor by amount of collateral\n     * @param assetId id of the asset with collateral requirements\n     * @param terms terms of the asset containing the collateral requirements\n     * @param ownership ownership of the asset\n     * @return true if the collateral was locked by the Custodian\n     */\n    function lockCollateral(\n        bytes32 assetId,\n        LifecycleTerms memory terms,\n        AssetOwnership memory ownership\n    )\n        public\n        override\n        returns (bool)\n    {\n        require(\n            terms.contractRole == ContractRole.BUY || terms.contractRole == ContractRole.SEL,\n            \"Custodian.lockCollateral: INVALID_CONTRACT_ROLE\"\n        );\n\n        require(\n            (terms.contractRole == ContractRole.BUY)\n                ? ownership.counterpartyObligor == address(this)\n                : ownership.creatorObligor == address(this),\n            \"Custodian.lockCollateral: INVALID_OWNERSHIP\"\n        );\n\n        // derive address of collateralizer\n        address collateralizer = (terms.contractRole == ContractRole.BUY)\n            ? ownership.counterpartyBeneficiary\n            : ownership.creatorBeneficiary;\n\n        // decode token address and amount of collateral\n        (address collateralToken, uint256 collateralAmount) = decodeCollateralObject(terms.contractReference_2.object);\n\n        require(\n            IERC20(collateralToken).allowance(collateralizer, address(this)) >= collateralAmount,\n            \"Custodian.lockCollateral: INSUFFICIENT_ALLOWANCE\"\n        );\n\n        // try transferring collateral from collateralizer to the custodian\n        require(\n            IERC20(collateralToken).transferFrom(collateralizer, address(this), collateralAmount),\n            \"Custodian.lockCollateral: TRANSFER_FAILED\"\n        );\n\n        // set allowance for AssetActor to later transfer collateral when XD is triggered\n        uint256 allowance = IERC20(collateralToken).allowance(address(this), assetActor);\n        require(\n            IERC20(collateralToken).approve(assetActor, allowance.add(collateralAmount)),\n            \"Custodian.lockCollateral: INCREASING_ALLOWANCE_FAILED\"\n        );\n\n        // register collateral for assetId\n        collateral[assetId] = true;\n\n        emit LockedCollateral(assetId, collateralizer, collateralAmount);\n\n        return true;\n    }\n\n    /**\n     * @notice Returns the entire collateral back to the collateralizer if collateral\n     * was not executed before the asset reached maturity or it returns the remaining\n     * collateral (not executed amount) after collateral was executed and settled\n     * @dev resets allowance for the Asset Actor,\n     * reverts if state of the asset does not allow unlocking the collateral\n     * @param assetId id of the asset for which to return the collateral,\n     * @return true if the collateral was returned to the collateralizer\n     */\n    function returnCollateral(\n        bytes32 assetId\n    )\n        public\n        override\n        returns (bool)\n    {\n        require(\n            collateral[assetId] == true,\n            \"Custodian.returnCollateral: ENTRY_DOES_NOT_EXIST\"\n        );\n\n        LifecycleTerms memory terms = assetRegistry.getTerms(assetId);\n        State memory state = assetRegistry.getState(assetId);\n        AssetOwnership memory ownership = assetRegistry.getOwnership(assetId);\n\n        // derive address of collateralizer\n        address collateralizer = (terms.contractRole == ContractRole.BUY)\n            ? ownership.counterpartyBeneficiary\n            : ownership.creatorBeneficiary;\n\n        // decode token address and amount of collateral\n        (address collateralToken, uint256 collateralAmount) = decodeCollateralObject(terms.contractReference_2.object);\n\n        // calculate amount to return\n        uint256 notExecutedAmount;\n        // if XD was triggerd\n        if (state.exerciseDate != uint256(0)) {\n            notExecutedAmount = collateralAmount.sub(\n                (state.exerciseAmount >= 0) ? uint256(state.exerciseAmount) : uint256(-1 * state.exerciseAmount)\n            );\n        // if XD was not triggered and (reached maturity or was terminated)\n        } else if (\n            state.exerciseDate == uint256(0)\n            && (state.contractPerformance == ContractPerformance.MD || state.contractPerformance == ContractPerformance.TD)\n        ) {\n            notExecutedAmount = collateralAmount;\n        // throw if XD was not triggered and maturity is not reached\n        } else {\n            revert(\"Custodian.returnCollateral: COLLATERAL_CAN_NOT_BE_RETURNED\");\n        }\n\n        // reset allowance for AssetActor\n        uint256 allowance = IERC20(collateralToken).allowance(address(this), assetActor);\n        require(\n            IERC20(collateralToken).approve(assetActor, allowance.sub(notExecutedAmount)),\n            \"Custodian.returnCollateral: DECREASING_ALLOWANCE_FAILD\"\n        );\n\n        // try transferring amount back to the collateralizer\n        require(\n            IERC20(collateralToken).transfer(collateralizer, notExecutedAmount),\n            \"Custodian.returnCollateral: TRANSFER_FAILED\"\n        );\n\n        emit ReturnedCollateral(assetId, collateralizer, notExecutedAmount);\n\n        return true;\n    }\n}\n"
    },
    "openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\ncontract ReentrancyGuard {\n    bool private _notEntered;\n\n    constructor () internal {\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive, but in exchange the refund on every call to nonReentrant\n        // will be lower in amount. Since refunds are capped to a percetange of\n        // the total transaction's gas, it is best to keep them low in cases\n        // like this one, to increase the likelihood of the full refund coming\n        // into effect.\n        _notEntered = true;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _notEntered = false;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _notEntered = true;\n    }\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "pragma solidity ^0.6.2;\n\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n"
    },
    "contracts/token/FDT/FundsDistributionToken.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nimport \"./SafeMathUint.sol\";\nimport \"./SafeMathInt.sol\";\n\nimport \"./IFundsDistributionToken.sol\";\n\n\n/**\n * @title FundsDistributionToken\n * @author Johannes Escherich\n * @author Roger-Wu\n * @author Johannes Pfeffer\n * @author Tom Lam\n * @dev A  mintable token that can represent claims on cash flow of arbitrary assets such as dividends, loan repayments,\n * fee or revenue shares among large numbers of token holders. Anyone can deposit funds, token holders can withdraw\n * their claims.\n * FundsDistributionToken (FDT) implements the accounting logic. FDT-Extension contracts implement methods for depositing and\n * withdrawing funds in Ether or according to a token standard such as ERC20, ERC223, ERC777.\n */\nabstract contract FundsDistributionToken is IFundsDistributionToken, ERC20, ERC20Detailed {\n\n\tusing SafeMath for uint256;\n\tusing SafeMathUint for uint256;\n\tusing SafeMathInt for int256;\n\n\t// optimize, see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n\tuint256 constant internal pointsMultiplier = 2**128;\n\tuint256 internal pointsPerShare;\n\n\tmapping(address => int256) internal pointsCorrection;\n\tmapping(address => uint256) internal withdrawnFunds;\n\n\n\tconstructor (\n\t\tstring memory name,\n\t\tstring memory symbol\n\t)\n\t\tpublic\n\t\tERC20Detailed(name, symbol, 18)\n\t{}\n\n\t/**\n\t * prev. distributeDividends\n\t * @notice Distributes funds to token holders.\n\t * @dev It reverts if the total supply of tokens is 0.\n\t * It emits the `FundsDistributed` event if the amount of received ether is greater than 0.\n\t * About undistributed funds:\n\t *   In each distribution, there is a small amount of funds which does not get distributed,\n\t *     which is `(msg.value * pointsMultiplier) % totalSupply()`.\n\t *   With a well-chosen `pointsMultiplier`, the amount funds that are not getting distributed\n\t *     in a distribution can be less than 1 (base unit).\n\t *   We can actually keep track of the undistributed ether in a distribution\n\t *     and try to distribute it in the next distribution ....... todo implement\n\t */\n\tfunction _distributeFunds(uint256 value) internal {\n\t\trequire(totalSupply() > 0, \"FundsDistributionToken._distributeFunds: SUPPLY_IS_ZERO\");\n\n\t\tif (value > 0) {\n\t\t\tpointsPerShare = pointsPerShare.add(\n\t\t\t\tvalue.mul(pointsMultiplier) / totalSupply()\n\t\t\t);\n\t\t\temit FundsDistributed(msg.sender, value);\n\t\t}\n\t}\n\n\t/**\n\t * prev. withdrawDividend\n\t * @notice Prepares funds withdrawal\n\t * @dev It emits a `FundsWithdrawn` event if the amount of withdrawn ether is greater than 0.\n\t */\n\tfunction _prepareWithdraw() internal returns (uint256) {\n\t\tuint256 _withdrawableDividend = withdrawableFundsOf(msg.sender);\n\n\t\twithdrawnFunds[msg.sender] = withdrawnFunds[msg.sender].add(_withdrawableDividend);\n\n\t\temit FundsWithdrawn(msg.sender, _withdrawableDividend);\n\n\t\treturn _withdrawableDividend;\n\t}\n\n\t/**\n\t * prev. withdrawableDividendOf\n\t * @notice View the amount of funds that an address can withdraw.\n\t * @param _owner The address of a token holder.\n\t * @return The amount funds that `_owner` can withdraw.\n\t */\n\tfunction withdrawableFundsOf(address _owner) public view override returns(uint256) {\n\t\treturn accumulativeFundsOf(_owner).sub(withdrawnFunds[_owner]);\n\t}\n\n\t/**\n\t * prev. withdrawnDividendOf\n\t * @notice View the amount of funds that an address has withdrawn.\n\t * @param _owner The address of a token holder.\n\t * @return The amount of funds that `_owner` has withdrawn.\n\t */\n\tfunction withdrawnFundsOf(address _owner) public view returns(uint256) {\n\t\treturn withdrawnFunds[_owner];\n\t}\n\n\t/**\n\t * prev. accumulativeDividendOf\n\t * @notice View the amount of funds that an address has earned in total.\n\t * @dev accumulativeFundsOf(_owner) = withdrawableFundsOf(_owner) + withdrawnFundsOf(_owner)\n\t * = (pointsPerShare * balanceOf(_owner) + pointsCorrection[_owner]) / pointsMultiplier\n\t * @param _owner The address of a token holder.\n\t * @return The amount of funds that `_owner` has earned in total.\n\t */\n\tfunction accumulativeFundsOf(address _owner) public view returns(uint256) {\n\t\treturn pointsPerShare.mul(balanceOf(_owner)).toInt256Safe()\n\t\t\t.add(pointsCorrection[_owner]).toUint256Safe() / pointsMultiplier;\n\t}\n\n\t/**\n\t * @dev Internal function that transfer tokens from one address to another.\n\t * Update pointsCorrection to keep funds unchanged.\n\t * @param from The address to transfer from.\n\t * @param to The address to transfer to.\n\t * @param value The amount to be transferred.\n\t */\n\tfunction _transfer(address from, address to, uint256 value) internal override {\n\t\tsuper._transfer(from, to, value);\n\n\t\tint256 _magCorrection = pointsPerShare.mul(value).toInt256Safe();\n\t\tpointsCorrection[from] = pointsCorrection[from].add(_magCorrection);\n\t\tpointsCorrection[to] = pointsCorrection[to].sub(_magCorrection);\n\t}\n\n\t/**\n\t * @dev Internal function that mints tokens to an account.\n\t * Update pointsCorrection to keep funds unchanged.\n\t * @param account The account that will receive the created tokens.\n\t * @param value The amount that will be created.\n\t */\n\tfunction _mint(address account, uint256 value) internal override {\n\t\tsuper._mint(account, value);\n\n\t\tpointsCorrection[account] = pointsCorrection[account]\n\t\t\t.sub( (pointsPerShare.mul(value)).toInt256Safe() );\n\t}\n\n\t/**\n\t * @dev Internal function that burns an amount of the token of a given account.\n\t * Update pointsCorrection to keep funds unchanged.\n\t * @param account The account whose tokens will be burnt.\n\t * @param value The amount that will be burnt.\n\t */\n\tfunction _burn(address account, uint256 value) internal override {\n\t\tsuper._burn(account, value);\n\n\t\tpointsCorrection[account] = pointsCorrection[account]\n\t\t\t.add( (pointsPerShare.mul(value)).toInt256Safe() );\n\t}\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20Mintable}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See {_burn} and {_approve}.\n     */\n    function _burnFrom(address account, uint256 amount) internal virtual {\n        _burn(account, amount);\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"ERC20: burn amount exceeds allowance\"));\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of `from`'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of `from`'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:using-hooks.adoc[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "openzeppelin-solidity/contracts/token/ERC20/ERC20Detailed.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Optional functions from the ERC20 standard.\n */\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n     * these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/token/FDT/SafeMathUint.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\n/**\n * @title SafeMathUint\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMathUint {\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n\n    require(b >= 0);\n\n    return b;\n  }\n}\n"
    },
    "contracts/token/FDT/SafeMathInt.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\n/**\n * @title SafeMathInt\n * @dev Math operations with safety checks that revert on error\n * @dev SafeMath adapted for int256\n * Based on code of  https://github.com/RequestNetwork/requestNetwork/blob/master/packages/requestNetworkSmartContracts/contracts/base/math/SafeMathInt.sol\n */\nlibrary SafeMathInt {\n\n  function mul(int256 a, int256 b) internal pure returns (int256) {\n    // Prevent overflow when multiplying INT256_MIN with -1\n    // https://github.com/RequestNetwork/requestNetwork/issues/43\n    require(!(a == - 2**255 && b == -1) && !(b == - 2**255 && a == -1));\n\n    int256 c = a * b;\n    require((b == 0) || (c / b == a));\n    return c;\n  }\n\n  function div(int256 a, int256 b) internal pure returns (int256) {\n    // Prevent overflow when dividing INT256_MIN by -1\n    // https://github.com/RequestNetwork/requestNetwork/issues/43\n    require(!(a == - 2**255 && b == -1) && (b > 0));\n\n    return a / b;\n  }\n\n  function sub(int256 a, int256 b) internal pure returns (int256) {\n    require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n\n    return a - b;\n  }\n\n  function add(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a + b;\n    require((b >= 0 && c >= a) || (b < 0 && c < a));\n    return c;\n  }\n\n  function toUint256Safe(int256 a) internal pure returns (uint256) {\n    require(a >= 0);\n    return uint256(a);\n  }\n}\n"
    },
    "contracts/token/FDT/IFundsDistributionToken.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\ninterface IFundsDistributionToken {\n\n\t/**\n\t * @dev Returns the total amount of funds a given address is able to withdraw currently.\n\t * @param owner Address of FundsDistributionToken holder\n\t * @return A uint256 representing the available funds for a given account\n\t */\n\tfunction withdrawableFundsOf(address owner) external view returns (uint256);\n\n\t/**\n\t * @dev Withdraws all available funds for a FundsDistributionToken holder.\n\t */\n\tfunction withdrawFunds() external;\n\n\t/**\n\t * @dev This event emits when new funds are distributed\n\t * @param by the address of the sender who distributed funds\n\t * @param fundsDistributed the amount of funds received for distribution\n\t */\n\tevent FundsDistributed(address indexed by, uint256 fundsDistributed);\n\n\t/**\n\t * @dev This event emits when distributed funds are withdrawn by a token holder.\n\t * @param by the address of the receiver of funds\n\t * @param fundsWithdrawn the amount of funds that were withdrawn\n\t */\n\tevent FundsWithdrawn(address indexed by, uint256 fundsWithdrawn);\n}\n"
    },
    "contracts/token/SettlementToken.sol": {
      "content": "pragma solidity ^0.6.4;\n\n\nlibrary SafeMath {\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        require(c >= a);\n    }\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        require(b <= a);\n        c = a - b;\n    }\n    function mul(uint a, uint b) internal pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b);\n    }\n    function div(uint a, uint b) internal pure returns (uint c) {\n        require(b > 0);\n        c = a / b;\n    }\n}\n\n\nabstract contract ERC20Interface {\n    function totalSupply() public view virtual returns (uint);\n    function balanceOf(address tokenOwner) public view virtual returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);\n    function transfer(address to, uint tokens) public virtual returns (bool success);\n    function approve(address spender, uint tokens) public virtual returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}\n\nabstract contract FaucetInterface {\n    function drip(address receiver, uint tokens) public virtual;\n}\n\nabstract contract ApproveAndCallFallBack {\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public virtual;\n}\n\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address indexed _from, address indexed _to);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public onlyOwner {\n        newOwner = _newOwner;\n    }\n    function acceptOwnership() public {\n        require(msg.sender == newOwner);\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = address(0);\n    }\n}\n\ncontract SettlementToken is ERC20Interface, FaucetInterface, Owned {\n    using SafeMath for uint;\n\n    string public symbol;\n    string public  name;\n    uint8 public decimals;\n    uint _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    constructor() public {\n        symbol = \"DAI\";\n        name = \"Test DAI\";\n        decimals = 18;\n        _totalSupply = 1000000 * 10**uint(decimals);\n        balances[owner] = _totalSupply;\n        emit Transfer(address(0), owner, _totalSupply);\n    }\n    function totalSupply() public view override returns (uint) {\n        return _totalSupply.sub(balances[address(0)]);\n    }\n    function balanceOf(address tokenOwner) public view override returns (uint balance) {\n        return balances[tokenOwner];\n    }\n    function transfer(address to, uint tokens) public override returns (bool success) {\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n    function approve(address spender, uint tokens) public override returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n        balances[from] = balances[from].sub(tokens);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\n        balances[to] = balances[to].add(tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n    function allowance(address tokenOwner, address spender) public view override returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }\n    function mint(address tokenOwner, uint tokens) internal returns (bool success) {\n        balances[tokenOwner] = balances[tokenOwner].add(tokens);\n        _totalSupply = _totalSupply.add(tokens);\n        emit Transfer(address(0), tokenOwner, tokens);\n        return true;\n    }\n    function drip(address receiver, uint tokens) public override {\n        mint(receiver, tokens);\n    }\n    fallback () external payable {\n        mint(msg.sender, 1000 * 10**uint(decimals));\n        if (msg.value > 0) {\n            msg.sender.transfer(msg.value);\n        }\n    }\n    // receive () external payable {\n    //     mint(msg.sender, 1000 * 10**uint(decimals));\n    //     if (msg.value > 0) {\n    //         msg.sender.transfer(msg.value);\n    //     }\n    // }\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\n    }\n}\n"
    },
    "contracts/token/SimpleRestrictedFDT.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"./FDT/FundsDistributionToken.sol\";\nimport \"./FDT/IFundsDistributionToken.sol\";\n\n\n/**\n * This contract allows a list of administrators to be tracked. This list can then be enforced\n * on functions with administrative permissions.  Only the owner of the contract should be allowed\n * to modify the administrator list.\n */\ncontract Administratable is Ownable {\n    // The mapping to track administrator accounts - true is reserved for admin addresses.\n    mapping(address => bool) public administrators;\n\n    // Events to allow tracking add/remove.\n    event AdminAdded(address indexed addedAdmin, address indexed addedBy);\n    event AdminRemoved(address indexed removedAdmin, address indexed removedBy);\n\n    /**\n    Function modifier to enforce administrative permissions.\n     */\n    modifier onlyAdministrator() {\n        require(\n            isAdministrator(msg.sender),\n            \"Calling account is not an administrator.\"\n        );\n        _;\n    }\n\n    /**\n    Determine if the message sender is in the administrators list.\n     */\n    function isAdministrator(address addressToTest) public view returns (bool) {\n        return administrators[addressToTest];\n    }\n\n    /**\n    Add an admin to the list.  This should only be callable by the owner of the contract.\n     */\n    function addAdmin(address adminToAdd) public onlyOwner {\n        // Verify the account is not already an admin\n        require(\n            administrators[adminToAdd] == false,\n            \"Account to be added to admin list is already an admin\"\n        );\n\n        // Set the address mapping to true to indicate it is an administrator account.\n        administrators[adminToAdd] = true;\n\n        // Emit the event for any watchers.\n        emit AdminAdded(adminToAdd, msg.sender);\n    }\n\n    /**\n    Remove an admin from the list.  This should only be callable by the owner of the contract.\n     */\n    function removeAdmin(address adminToRemove) public onlyOwner {\n        // Verify the account is an admin\n        require(\n            administrators[adminToRemove] == true,\n            \"Account to be removed from admin list is not already an admin\"\n        );\n\n        // Set the address mapping to false to indicate it is NOT an administrator account.\n        administrators[adminToRemove] = false;\n\n        // Emit the event for any watchers.\n        emit AdminRemoved(adminToRemove, msg.sender);\n    }\n}\n\n/**\nKeeps track of whitelists and can check if sender and reciever are configured to allow a transfer.\nOnly administrators can update the whitelists.\nAny address can only be a member of one whitelist at a time.\n */\ncontract Whitelistable is Administratable {\n    // Zero is reserved for indicating it is not on a whitelist\n    uint8 constant NO_WHITELIST = 0;\n\n    // The mapping to keep track of which whitelist any address belongs to.\n    // 0 is reserved for no whitelist and is the default for all addresses.\n    mapping(address => uint8) public addressWhitelists;\n\n    // The mapping to keep track of each whitelist's outbound whitelist flags.\n    // Boolean flag indicates whether outbound transfers are enabled.\n    mapping(uint8 => mapping(uint8 => bool)) public outboundWhitelistsEnabled;\n\n    // Events to allow tracking add/remove.\n    event AddressAddedToWhitelist(\n        address indexed addedAddress,\n        uint8 indexed whitelist,\n        address indexed addedBy\n    );\n    event AddressRemovedFromWhitelist(\n        address indexed removedAddress,\n        uint8 indexed whitelist,\n        address indexed removedBy\n    );\n    event OutboundWhitelistUpdated(\n        address indexed updatedBy,\n        uint8 indexed sourceWhitelist,\n        uint8 indexed destinationWhitelist,\n        bool from,\n        bool to\n    );\n\n    /**\n    Sets an address's white list ID.  Only administrators should be allowed to update this.\n    If an address is on an existing whitelist, it will just get updated to the new value (removed from previous).\n     */\n    function addToWhitelist(address addressToAdd, uint8 whitelist)\n        public\n        onlyAdministrator\n    {\n        // Verify the whitelist is valid\n        require(whitelist != NO_WHITELIST, \"Invalid whitelist ID supplied\");\n\n        // Save off the previous white list\n        uint8 previousWhitelist = addressWhitelists[addressToAdd];\n\n        // Set the address's white list ID\n        addressWhitelists[addressToAdd] = whitelist;\n\n        // If the previous whitelist existed then we want to indicate it has been removed\n        if (previousWhitelist != NO_WHITELIST) {\n            // Emit the event for tracking\n            emit AddressRemovedFromWhitelist(\n                addressToAdd,\n                previousWhitelist,\n                msg.sender\n            );\n        }\n\n        // Emit the event for new whitelist\n        emit AddressAddedToWhitelist(addressToAdd, whitelist, msg.sender);\n    }\n\n    /**\n    Clears out an address's white list ID.  Only administrators should be allowed to update this.\n     */\n    function removeFromWhitelist(address addressToRemove)\n        public\n        onlyAdministrator\n    {\n        // Save off the previous white list\n        uint8 previousWhitelist = addressWhitelists[addressToRemove];\n\n        // Zero out the previous white list\n        addressWhitelists[addressToRemove] = NO_WHITELIST;\n\n        // Emit the event for tracking\n        emit AddressRemovedFromWhitelist(\n            addressToRemove,\n            previousWhitelist,\n            msg.sender\n        );\n    }\n\n    /**\n    Sets the flag to indicate whether source whitelist is allowed to send to destination whitelist.\n    Only administrators should be allowed to update this.\n     */\n    function updateOutboundWhitelistEnabled(\n        uint8 sourceWhitelist,\n        uint8 destinationWhitelist,\n        bool newEnabledValue\n    ) public onlyAdministrator {\n        // Get the old enabled flag\n        bool oldEnabledValue = outboundWhitelistsEnabled[sourceWhitelist][destinationWhitelist];\n\n        // Update to the new value\n        outboundWhitelistsEnabled[sourceWhitelist][destinationWhitelist] = newEnabledValue;\n\n        // Emit event for tracking\n        emit OutboundWhitelistUpdated(\n            msg.sender,\n            sourceWhitelist,\n            destinationWhitelist,\n            oldEnabledValue,\n            newEnabledValue\n        );\n    }\n\n    /**\n    Determine if the a sender is allowed to send to the receiver.\n    The source whitelist must be enabled to send to the whitelist where the receive exists.\n     */\n    function checkWhitelistAllowed(address sender, address receiver)\n        public\n        view\n        returns (bool)\n    {\n        // First get each address white list\n        uint8 senderWhiteList = addressWhitelists[sender];\n        uint8 receiverWhiteList = addressWhitelists[receiver];\n\n        // If either address is not on a white list then the check should fail\n        if (\n            senderWhiteList == NO_WHITELIST || receiverWhiteList == NO_WHITELIST\n        ) {\n            return false;\n        }\n\n        // Determine if the sending whitelist is allowed to send to the destination whitelist\n        return outboundWhitelistsEnabled[senderWhiteList][receiverWhiteList];\n    }\n}\n\n/**\nRestrictions start off as enabled.\nOnce they are disabled, they cannot be re-enabled.\nOnly the owner may disable restrictions.\n */\ncontract Restrictable is Ownable {\n    // State variable to track whether restrictions are enabled.  Defaults to true.\n    bool private _restrictionsEnabled = true;\n\n    // Event emitted when flag is disabled\n    event RestrictionsDisabled(address indexed owner);\n\n    /**\n    View function to determine if restrictions are enabled\n     */\n    function isRestrictionEnabled() public view returns (bool) {\n        return _restrictionsEnabled;\n    }\n\n    /**\n    Function to update the enabled flag on restrictions to disabled.  Only the owner should be able to call.\n    This is a permanent change that cannot be undone\n     */\n    function disableRestrictions() public onlyOwner {\n        require(_restrictionsEnabled, \"Restrictions are already disabled.\");\n\n        // Set the flag\n        _restrictionsEnabled = false;\n\n        // Trigger the event\n        emit RestrictionsDisabled(msg.sender);\n    }\n}\n\nabstract contract ERC1404 is IERC20 {\n    /// @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n    /// @param from Sending address\n    /// @param to Receiving address\n    /// @param value Amount of tokens being transferred\n    /// @return Code by which to reference message for rejection reasoning\n    /// @dev Overwrite with your custom transfer restriction logic\n    function detectTransferRestriction(address from, address to, uint256 value)\n        public\n        view\n        virtual\n        returns (uint8);\n\n    /// @notice Returns a human-readable message for a given restriction code\n    /// @param restrictionCode Identifier for looking up a message\n    /// @return Text showing the restriction's reasoning\n    /// @dev Overwrite with your custom message and restrictionCode handling\n    function messageForTransferRestriction(uint8 restrictionCode)\n        public\n        view\n        virtual\n        returns (string memory);\n}\n\ncontract SimpleRestrictedFDT is\n    IFundsDistributionToken,\n    FundsDistributionToken,\n    ERC1404,\n    Whitelistable,\n    Restrictable\n{\n    using SafeMathUint for uint256;\n    using SafeMathInt for int256;\n\n    // ERC1404 Error codes and messages\n    uint8 public constant SUCCESS_CODE = 0;\n    uint8 public constant FAILURE_NON_WHITELIST = 1;\n    string public constant SUCCESS_MESSAGE = \"SUCCESS\";\n    string public constant FAILURE_NON_WHITELIST_MESSAGE = \"The transfer was restricted due to white list configuration.\";\n    string public constant UNKNOWN_ERROR = \"Unknown Error Code\";\n\n    // token in which the funds can be sent to the FundsDistributionToken\n    IERC20 public fundsToken;\n\n    // balance of fundsToken that the FundsDistributionToken currently holds\n    uint256 public fundsTokenBalance;\n\n    modifier onlyFundsToken() {\n        require(\n            msg.sender == address(fundsToken),\n            \"FDT_ERC20Extension.onlyFundsToken: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        IERC20 _fundsToken,\n        address owner,\n        uint256 initialAmount\n    ) public FundsDistributionToken(name, symbol) {\n        require(\n            address(_fundsToken) != address(0),\n            \"SimpleRestrictedFDT: INVALID_FUNDS_TOKEN_ADDRESS\"\n        );\n\n        fundsToken = _fundsToken;\n        _transferOwnership(owner);\n        _mint(owner, initialAmount);\n    }\n\n    /**\n  \tThis function detects whether a transfer should be restricted and not allowed.\n  \tIf the function returns SUCCESS_CODE (0) then it should be allowed.\n  \t*/\n    function detectTransferRestriction(address from, address to, uint256)\n        public\n        view\n        override\n        returns (uint8)\n    {\n        // If the restrictions have been disabled by the owner, then just return success\n        // Logic defined in Restrictable parent class\n        if (!isRestrictionEnabled()) {\n            return SUCCESS_CODE;\n        }\n\n        // If the contract owner is transferring, then ignore reistrictions\n        if (from == owner()) {\n            return SUCCESS_CODE;\n        }\n\n        // Restrictions are enabled, so verify the whitelist config allows the transfer.\n        // Logic defined in Whitelistable parent class\n        if (!checkWhitelistAllowed(from, to)) {\n            return FAILURE_NON_WHITELIST;\n        }\n\n        // If no restrictions were triggered return success\n        return SUCCESS_CODE;\n    }\n\n    /**\n  \tThis function allows a wallet or other client to get a human readable string to show\n  \ta user if a transfer was restricted.  It should return enough information for the user\n  \tto know why it failed.\n  \t*/\n    function messageForTransferRestriction(uint8 restrictionCode)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        if (restrictionCode == SUCCESS_CODE) {\n            return SUCCESS_MESSAGE;\n        }\n\n        if (restrictionCode == FAILURE_NON_WHITELIST) {\n            return FAILURE_NON_WHITELIST_MESSAGE;\n        }\n\n        // An unknown error code was passed in.\n        return UNKNOWN_ERROR;\n    }\n\n    /**\n  \tEvaluates whether a transfer should be allowed or not.\n  \t*/\n    modifier notRestricted(address from, address to, uint256 value) {\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\n        require(\n            restrictionCode == SUCCESS_CODE,\n            messageForTransferRestriction(restrictionCode)\n        );\n        _;\n    }\n\n    /**\n  \tOverrides the parent class token transfer function to enforce restrictions.\n  \t*/\n    function transfer(address to, uint256 value)\n        public\n        notRestricted(msg.sender, to, value)\n        override(IERC20, ERC20)\n        returns (bool success)\n    {\n        success = super.transfer(to, value);\n    }\n\n    /**\n  \tOverrides the parent class token transferFrom function to enforce restrictions.\n  \t*/\n    function transferFrom(address from, address to, uint256 value)\n        public\n        notRestricted(from, to, value)\n        override(IERC20, ERC20)\n        returns (bool success)\n    {\n        success = super.transferFrom(from, to, value);\n    }\n\n    /**\n\t * @notice Withdraws all available funds for a token holder\n\t */\n    function withdrawFunds() external override {\n        uint256 withdrawableFunds = _prepareWithdraw();\n\n        require(\n            fundsToken.transfer(msg.sender, withdrawableFunds),\n            \"FDT_ERC20Extension.withdrawFunds: TRANSFER_FAILED\"\n        );\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n\t * @dev Updates the current funds token balance \n\t * and returns the difference of new and previous funds token balances\n\t * @return A int256 representing the difference of the new and previous funds token balance\n\t */\n    function _updateFundsTokenBalance() internal returns (int256) {\n        uint256 prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = fundsToken.balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(prevFundsTokenBalance));\n    }\n\n    /**\n\t * @notice Register a payment of funds in tokens. May be called directly after a deposit is made.\n\t * @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the previous and the new \n\t * funds token balance and increments the total received funds (cumulative) by delta by calling _registerFunds()\n\t */\n    function updateFundsReceived() external {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds > 0) {\n            _distributeFunds(newFunds.toUint256Safe());\n        }\n    }\n}\n"
    },
    "contracts/token/VanillaFDT.sol": {
      "content": "pragma solidity ^0.6.4;\n\nimport \"openzeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"./FDT/FundsDistributionToken.sol\";\nimport \"./FDT/IFundsDistributionToken.sol\";\n\n\ncontract VanillaFDT is IFundsDistributionToken, FundsDistributionToken, Ownable {\n\n    using SafeMathUint for uint256;\n    using SafeMathInt for int256;\n\n\n    // token in which the funds can be sent to the FundsDistributionToken\n    IERC20 public fundsToken;\n\n    // balance of fundsToken that the FundsDistributionToken currently holds\n    uint256 public fundsTokenBalance;\n\n    modifier onlyFundsToken() {\n        require(\n            msg.sender == address(fundsToken),\n            \"FDT_ERC20Extension.onlyFundsToken: UNAUTHORIZED_SENDER\"\n        );\n        _;\n    }\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        IERC20 _fundsToken,\n        address owner,\n        uint256 initialAmount\n    )\n        public\n        FundsDistributionToken(name, symbol)\n    {\n        require(\n            address(_fundsToken) != address(0),\n            \"SimpleRestrictedFDT: INVALID_FUNDS_TOKEN_ADDRESS\"\n        );\n\n        fundsToken = _fundsToken;\n        _transferOwnership(owner);\n        _mint(owner, initialAmount);\n    }\n\n    /**\n      Overrides the parent class token transfer function to enforce restrictions.\n      */\n    function transfer(address to, uint256 value) public override returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    /**\n      Overrides the parent class token transferFrom function to enforce restrictions.\n      */\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    /**\n     * @notice Withdraws all available funds for a token holder\n     */\n    function withdrawFunds() external override {\n        uint256 withdrawableFunds = _prepareWithdraw();\n\n        require(\n            fundsToken.transfer(msg.sender, withdrawableFunds),\n            \"FDT_ERC20Extension.withdrawFunds: TRANSFER_FAILED\"\n        );\n\n        _updateFundsTokenBalance();\n    }\n\n    /**\n     * @dev Updates the current funds token balance\n     * and returns the difference of new and previous funds token balances\n     * @return A int256 representing the difference of the new and previous funds token balance\n     */\n    function _updateFundsTokenBalance() internal returns (int256) {\n        uint256 prevFundsTokenBalance = fundsTokenBalance;\n\n        fundsTokenBalance = fundsToken.balanceOf(address(this));\n\n        return int256(fundsTokenBalance).sub(int256(prevFundsTokenBalance));\n    }\n\n    /**\n     * @notice Register a payment of funds in tokens. May be called directly after a deposit is made.\n     * @dev Calls _updateFundsTokenBalance(), whereby the contract computes the delta of the previous and the new\n     * funds token balance and increments the total received funds (cumulative) by delta by calling _registerFunds()\n     */\n    function updateFundsReceived() external {\n        int256 newFunds = _updateFundsTokenBalance();\n\n        if (newFunds > 0) {\n            _distributeFunds(newFunds.toUint256Safe());\n        }\n    }\n}\n"
    },
    "contracts/Tokenization/TokenizationFactory.sol": {
      "content": "pragma solidity ^0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../Core/AssetRegistry/IAssetRegistry.sol\";\nimport \"../token/SimpleRestrictedFDT.sol\";\nimport \"../token/VanillaFDT.sol\";\n\n\n/**\n * @title TokenizationFactory\n * @notice Factory for deploying FDT contracts\n */\ncontract TokenizationFactory {\n\n    IAssetRegistry public assetRegistry;\n\n\n    event DeployedDistributor(address distributor, address creator);\n\n    constructor(IAssetRegistry _assetRegistry) public {\n        assetRegistry = _assetRegistry;\n    }\n\n    /**\n     * deploys a new tokenized distributor contract for a specified ERC20 token\n     * @dev mints initial supply after deploying the tokenized distributor contract\n     * @param name name of the token\n     * @param symbol of the token\n     * @param initialSupply of distributor tokens\n     */\n    function createERC20Distributor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        IERC20 token,\n        address owner\n    )\n        public\n    {\n        require(\n            address(token) != address(0),\n            \"TokenizationFactory.createERC20Distributor: INVALID_FUNCTION_PARAMETERS\"\n        );\n\n        VanillaFDT distributor = new VanillaFDT(name, symbol, token, owner, initialSupply);\n\n        emit DeployedDistributor(address(distributor), owner);\n    }\n\n    /**\n     * deploys a new restricted tokenized distributor contract for a specified ERC20 token\n     * @dev mints initial supply after deploying the tokenized distributor contract\n     * @param name name of the token\n     * @param symbol of the token\n     * @param initialSupply of distributor tokens\n     */\n    function createRestrictedERC20Distributor(\n        string memory name,\n        string memory symbol,\n        uint256 initialSupply,\n        IERC20 token,\n        address owner\n    )\n        public\n    {\n        require(\n            address(token) != address(0),\n            \"TokenizationFactory.createERC20Distributor: INVALID_FUNCTION_PARAMETERS\"\n        );\n\n        SimpleRestrictedFDT distributor = new SimpleRestrictedFDT(name, symbol, token, owner, initialSupply);\n\n        emit DeployedDistributor(address(distributor), msg.sender);\n    }\n}"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}